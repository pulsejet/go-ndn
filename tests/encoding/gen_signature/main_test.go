package gen_signature_test

import (
	"crypto/sha256"
	"testing"

	"github.com/stretchr/testify/require"
	enc "github.com/zjkmxy/go-ndn/pkg/encoding"
	"github.com/zjkmxy/go-ndn/pkg/utils"
	def "github.com/zjkmxy/go-ndn/tests/encoding/gen_signature"
)

func TestT1(t *testing.T) {
	utils.SetTestingT(t)

	// Normal case (w/ & w/o sig.)
	f := &def.T1{
		H1: 1,
		H2: utils.ConstPtr[uint64](2),
		C: enc.Wire{
			[]byte{0x01, 0x02, 0x03},
			[]byte{0x04, 0x05, 0x06},
		},
	}
	wire, cov := f.Encode(5, []byte{0x07, 0x08, 0x09})
	require.GreaterOrEqual(t, len(wire), 5)
	require.GreaterOrEqual(t, len(cov), 1)
	require.Equal(t, []byte{
		0x01, 0x01, 0x01, 0x02, 0x01, 0x02,
		0x03, 0x06, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
		0x04, 0x03, 0x07, 0x08, 0x09,
	}, wire.Join())
	require.Equal(t, []byte{
		0x02, 0x01, 0x02,
		0x03, 0x06, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
	}, cov.Join())
	f2, cov2, err := def.ReadT1(enc.NewWireReader(wire))
	require.NoError(t, err)
	require.Equal(t, f.H1, f2.H1)
	require.Equal(t, f.H2, f2.H2)
	require.Equal(t, f.C.Join(), f2.C.Join())
	require.Equal(t, []byte{0x07, 0x08, 0x09}, f2.Sig.Join())
	require.Equal(t, cov.Join(), cov2.Join())

	wire, _ = f.Encode(0, nil)
	require.GreaterOrEqual(t, len(wire), 3)
	require.Equal(t, []byte{
		0x01, 0x01, 0x01, 0x02, 0x01, 0x02,
		0x03, 0x06, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
	}, wire.Join())
	f2, _, err = def.ReadT1(enc.NewWireReader(wire))
	require.NoError(t, err)
	require.Equal(t, f.H1, f2.H1)
	require.Equal(t, f.H2, f2.H2)
	require.Equal(t, f.C.Join(), f2.C.Join())
	require.Equal(t, 0, len(f2.Sig.Join()))

	// Single wire
	f = &def.T1{
		H1: 4,
		H2: nil,
		C: enc.Wire{
			[]byte{0x01, 0x02, 0x03},
		},
	}
	wire, cov = f.Encode(1, []byte{0x01})
	require.GreaterOrEqual(t, len(wire), 4)
	require.GreaterOrEqual(t, len(cov), 1)
	require.Equal(t, []byte{
		0x01, 0x01, 0x04,
		0x03, 0x03, 0x01, 0x02, 0x03,
		0x04, 0x01, 0x01,
	}, wire.Join())
	require.Equal(t, []byte{0x03, 0x03, 0x01, 0x02, 0x03}, cov.Join())
	f2, cov2, err = def.ReadT1(enc.NewWireReader(wire))
	require.NoError(t, err)
	require.Equal(t, f.H1, f2.H1)
	require.True(t, f2.H2 == nil)
	require.Equal(t, f.C.Join(), f2.C.Join())
	require.Equal(t, []byte{0x01}, f2.Sig.Join())
	require.Equal(t, cov.Join(), cov2.Join())

	// Empty wire
	f = &def.T1{
		H1: 0,
		H2: nil,
		C:  enc.Wire{},
	}
	wire, cov = f.Encode(1, []byte{0x01})
	require.GreaterOrEqual(t, len(wire), 2)
	require.GreaterOrEqual(t, len(cov), 1)
	require.Equal(t, []byte{
		0x01, 0x01, 0x00,
		0x03, 0x00,
		0x04, 0x01, 0x01,
	}, wire.Join())
	require.Equal(t, []byte{0x03, 0x00}, cov.Join())
	f2, cov2, err = def.ReadT1(enc.NewWireReader(wire))
	require.NoError(t, err)
	require.Equal(t, f.H1, f2.H1)
	require.True(t, f2.H2 == nil)
	require.Equal(t, enc.Wire{}, f2.C)
	require.Equal(t, []byte{0x01}, f2.Sig.Join())
	require.Equal(t, cov.Join(), cov2.Join())

	// Nil case
	f = &def.T1{
		H1: 0,
		H2: nil,
		C:  nil,
	}
	wire, cov = f.Encode(1, []byte{0x01})
	require.GreaterOrEqual(t, len(wire), 2)
	require.GreaterOrEqual(t, len(cov), 1)
	require.Equal(t, []byte{
		0x01, 0x01, 0x00,
		0x04, 0x01, 0x01,
	}, wire.Join())
	require.Equal(t, 0, len(cov.Join()))
	f2, cov2, err = def.ReadT1(enc.NewWireReader(wire))
	require.NoError(t, err)
	require.Equal(t, f.H1, f2.H1)
	require.True(t, f2.H2 == nil)
	require.True(t, f2.C == nil)
	require.Equal(t, []byte{0x01}, f2.Sig.Join())
	require.Equal(t, 0, len(cov2.Join()))
}

func TestT2(t *testing.T) {
	utils.SetTestingT(t)

	// Normal case (w/o & w/ digest)
	f := &def.T2{
		Name: utils.WithoutErr(enc.NameFromStr("/ndn/test")),
		C: enc.Wire{
			[]byte{0x01, 0x02, 0x03},
			[]byte{0x04, 0x05, 0x06},
		},
	}
	wire, cov := f.Encode(5, []byte{7, 8, 9}, false)
	require.Equal(t, []byte{
		0x1, 0xb, 0x8, 0x3, 0x6e, 0x64, 0x6e, 0x8, 0x4, 0x74, 0x65, 0x73, 0x74,
		0x3, 0x6, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6,
		0x4, 0x3, 0x7, 0x8, 0x9,
	}, wire.Join())
	require.Equal(t, []byte{
		0x8, 0x3, 0x6e, 0x64, 0x6e, 0x8, 0x4, 0x74, 0x65, 0x73, 0x74,
		0x3, 0x6, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6,
	}, cov.Join())
	// TODO: read

	wire, cov = f.Encode(5, []byte{7, 8, 9}, true)
	h := sha256.New()
	h.Write([]byte{0x3, 0x6, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x4, 0x3, 0x7, 0x8, 0x9})
	require.Equal(t, []byte{
		0x69, 0xea, 0x9a, 0xcd, 0xe0, 0x94, 0x58, 0xbb, 0x5, 0x40, 0xe1, 0xcf, 0xa6, 0xae, 0xd0, 0x10,
		0x47, 0x30, 0x8f, 0x71, 0xa5, 0xf5, 0x16, 0xda, 0xba, 0x51, 0x65, 0x77, 0x82, 0x32, 0x15, 0x6d,
	}, h.Sum(nil))
	require.Equal(t, []byte{
		0x1, 0x2d, 0x8, 0x3, 0x6e, 0x64, 0x6e, 0x8, 0x4, 0x74, 0x65, 0x73, 0x74, 0x2, 0x20,
		0x69, 0xea, 0x9a, 0xcd, 0xe0, 0x94, 0x58, 0xbb, 0x5, 0x40, 0xe1, 0xcf, 0xa6, 0xae, 0xd0, 0x10,
		0x47, 0x30, 0x8f, 0x71, 0xa5, 0xf5, 0x16, 0xda, 0xba, 0x51, 0x65, 0x77, 0x82, 0x32, 0x15, 0x6d,
		0x3, 0x6, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6,
		0x4, 0x3, 0x7, 0x8, 0x9,
	}, wire.Join())
	require.Equal(t, []byte{
		0x8, 0x3, 0x6e, 0x64, 0x6e, 0x8, 0x4, 0x74, 0x65, 0x73, 0x74,
		0x3, 0x6, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6,
	}, cov.Join())
	// TODO: read

	// User provided digest component

	// No wire
	f = &def.T2{
		Name: enc.Name{},
		C:    enc.Wire{},
	}
	wire, cov = f.Encode(1, []byte{1}, true)
	h = sha256.New()
	h.Write([]byte{0x4, 0x1, 0x1})
	require.Equal(t, []byte{
		0x62, 0xec, 0x79, 0xd1, 0xde, 0xeb, 0x1e, 0xcc, 0x44, 0x4e, 0x8e, 0x30, 0x28, 0xec, 0xba, 0x63,
		0xc9, 0x65, 0x12, 0x53, 0xeb, 0x79, 0xae, 0x3d, 0x7b, 0xc7, 0xd4, 0xff, 0x12, 0x6a, 0x74, 0x54,
	}, h.Sum(nil))
}
