// Generated by the generator, DO NOT modify manually
package gen_basic

import (
	"encoding/binary"
	"io"
	"time"

	enc "github.com/zjkmxy/go-ndn/pkg/encoding"
)

type FakeMetaInfoEncoder struct {
	length uint
}

func (encoder *FakeMetaInfoEncoder) init(value *FakeMetaInfo) {

	l := uint(0)
	l += 1
	switch x := value.Number; {
	case x <= 0xff:
		l += 2
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}

	l += 1
	switch x := uint64(value.Time / time.Millisecond); {
	case x <= 0xff:
		l += 2
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}

	if value.Binary != nil {
		l += 1
		switch x := len(value.Binary); {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		l += uint(len(value.Binary))
	}

	encoder.length = l

}

func (encoder *FakeMetaInfoEncoder) encode(value *FakeMetaInfo) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.length)
	buf := wire[0]
	pos := uint(0)

	buf[pos] = byte(24)
	pos += 1
	switch x := value.Number; {
	case x <= 0xff:
		buf[pos] = 1
		buf[pos+1] = byte(x)
		pos += 2
	case x <= 0xffff:
		buf[pos] = 2
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 4
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 8
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}

	buf[pos] = byte(25)
	pos += 1
	switch x := uint64(value.Time / time.Millisecond); {
	case x <= 0xff:
		buf[pos] = 1
		buf[pos+1] = byte(x)
		pos += 2
	case x <= 0xffff:
		buf[pos] = 2
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 4
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 8
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}

	if value.Binary != nil {
		buf[pos] = byte(26)
		pos += 1
		switch x := len(value.Binary); {
		case x <= 0xfc:
			buf[pos] = byte(x)
			pos += 1
		case x <= 0xffff:
			buf[pos] = 0xfd
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 0xfe
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 0xff
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
		copy(buf[pos:], value.Binary)
		pos += uint(len(value.Binary))
	}

	return wire
}

func ParseFakeMetaInfo(reader enc.ParseReader, ignoreCritical bool) (*FakeMetaInfo, error) {
	progress := -1
	value := &FakeMetaInfo{}
	var err error
	for reader.Pos() < reader.Length() {
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		err = nil
		for handled := false; !handled; progress++ {
			switch typ {
			case 24:
				if progress+1 == 0 {
					handled = true
					value.Number = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x, err := reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.Number = uint64(value.Number<<8) | uint64(x)
						}
					}
				}
			case 25:
				if progress+1 == 1 {
					handled = true
					{
						timeInt := uint64(0)
						timeInt = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x, err := reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								timeInt = uint64(timeInt<<8) | uint64(x)
							}
						}
						value.Time = time.Duration(timeInt) * time.Millisecond
					}

				}
			case 26:
				if progress+1 == 2 {
					handled = true
					value.Binary = make([]byte, l)
					_, err = io.ReadFull(reader, value.Binary)

				}
			default:
				handled = true
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				_, err = reader.Seek(int64(l), io.SeekCurrent)
			}
			if err == nil && !handled {
				switch progress {
				case 0 - 1:
					err = enc.ErrSkipRequired{TypeNum: typ}
				case 1 - 1:
					err = enc.ErrSkipRequired{TypeNum: typ}
				case 2 - 1:
					value.Binary = nil
				}
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}
	return value, nil
}

func (value *FakeMetaInfo) Encode() enc.Wire {
	encoder := FakeMetaInfoEncoder{}
	encoder.init(value)
	return encoder.encode(value)
}

func (value *FakeMetaInfo) Bytes() []byte {
	return value.Encode().Join()
}

type OptFieldEncoder struct {
	length uint
}

func (encoder *OptFieldEncoder) init(value *OptField) {

	l := uint(0)
	if value.Number != nil {
		l += 1
		switch x := *value.Number; {
		case x <= 0xff:
			l += 2
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
	}

	if value.Time != nil {
		l += 1
		switch x := uint64(*value.Time / time.Millisecond); {
		case x <= 0xff:
			l += 2
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
	}

	if value.Binary != nil {
		l += 1
		switch x := len(value.Binary); {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		l += uint(len(value.Binary))
	}

	encoder.length = l

}

func (encoder *OptFieldEncoder) encode(value *OptField) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.length)
	buf := wire[0]
	pos := uint(0)

	if value.Number != nil {
		buf[pos] = byte(24)
		pos += 1
		switch x := *value.Number; {
		case x <= 0xff:
			buf[pos] = 1
			buf[pos+1] = byte(x)
			pos += 2
		case x <= 0xffff:
			buf[pos] = 2
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 4
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 8
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
	}

	if value.Time != nil {
		buf[pos] = byte(25)
		pos += 1
		switch x := uint64(*value.Time / time.Millisecond); {
		case x <= 0xff:
			buf[pos] = 1
			buf[pos+1] = byte(x)
			pos += 2
		case x <= 0xffff:
			buf[pos] = 2
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 4
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 8
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
	}

	if value.Binary != nil {
		buf[pos] = byte(26)
		pos += 1
		switch x := len(value.Binary); {
		case x <= 0xfc:
			buf[pos] = byte(x)
			pos += 1
		case x <= 0xffff:
			buf[pos] = 0xfd
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 0xfe
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 0xff
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
		copy(buf[pos:], value.Binary)
		pos += uint(len(value.Binary))
	}

	return wire
}

func ParseOptField(reader enc.ParseReader, ignoreCritical bool) (*OptField, error) {
	progress := -1
	value := &OptField{}
	var err error
	for reader.Pos() < reader.Length() {
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		err = nil
		for handled := false; !handled; progress++ {
			switch typ {
			case 24:
				if progress+1 == 0 {
					handled = true
					{
						tempVal := uint64(0)
						tempVal = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x, err := reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								tempVal = uint64(tempVal<<8) | uint64(x)
							}
						}
						value.Number = &tempVal
					}

				}
			case 25:
				if progress+1 == 1 {
					handled = true
					{
						timeInt := uint64(0)
						timeInt = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x, err := reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								timeInt = uint64(timeInt<<8) | uint64(x)
							}
						}
						tempVal := time.Duration(timeInt) * time.Millisecond
						value.Time = &tempVal
					}

				}
			case 26:
				if progress+1 == 2 {
					handled = true
					value.Binary = make([]byte, l)
					_, err = io.ReadFull(reader, value.Binary)

				}
			default:
				handled = true
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				_, err = reader.Seek(int64(l), io.SeekCurrent)
			}
			if err == nil && !handled {
				switch progress {
				case 0 - 1:
					value.Number = nil
				case 1 - 1:
					value.Time = nil
				case 2 - 1:
					value.Binary = nil
				}
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}
	return value, nil
}

func (value *OptField) Encode() enc.Wire {
	encoder := OptFieldEncoder{}
	encoder.init(value)
	return encoder.encode(value)
}

func (value *OptField) Bytes() []byte {
	return value.Encode().Join()
}
