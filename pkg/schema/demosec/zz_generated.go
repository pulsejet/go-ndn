// Code generated by ndn tlv codegen DO NOT EDIT.
package demosec

import (
	"encoding/binary"
	"io"

	enc "github.com/zjkmxy/go-ndn/pkg/encoding"
)

type EncryptedContentEncoder struct {
	length uint

	wirePlan []uint

	CipherText_length uint
}

type EncryptedContentParsingContext struct {
}

func (encoder *EncryptedContentEncoder) Init(value *EncryptedContent) {

	if value.CipherText != nil {
		encoder.CipherText_length = 0
		for _, c := range value.CipherText {
			encoder.CipherText_length += uint(len(c))
		}
	}

	l := uint(0)
	if value.KeyId != nil {
		l += 1
		switch x := len(value.KeyId); {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		l += uint(len(value.KeyId))
	}
	if value.Iv != nil {
		l += 1
		switch x := len(value.Iv); {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		l += uint(len(value.Iv))
	}
	l += 1
	switch x := value.ContentLength; {
	case x <= 0xff:
		l += 2
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	if value.CipherText != nil {
		l += 1
		switch x := encoder.CipherText_length; {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		l += encoder.CipherText_length
	}
	encoder.length = l

	wirePlan := make([]uint, 0)
	l = uint(0)
	if value.KeyId != nil {
		l += 1
		switch x := len(value.KeyId); {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		l += uint(len(value.KeyId))
	}
	if value.Iv != nil {
		l += 1
		switch x := len(value.Iv); {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		l += uint(len(value.Iv))
	}
	l += 1
	switch x := value.ContentLength; {
	case x <= 0xff:
		l += 2
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	if value.CipherText != nil {
		l += 1
		switch x := encoder.CipherText_length; {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		wirePlan = append(wirePlan, l)
		l = 0
		for range value.CipherText {
			wirePlan = append(wirePlan, l)
			l = 0
		}
	}
	if l > 0 {
		wirePlan = append(wirePlan, l)
	}
	encoder.wirePlan = wirePlan
}

func (context *EncryptedContentParsingContext) Init() {

}

func (encoder *EncryptedContentEncoder) EncodeInto(value *EncryptedContent, wire enc.Wire) {

	wireIdx := 0
	buf := wire[wireIdx]

	pos := uint(0)

	if value.KeyId != nil {
		buf[pos] = byte(130)
		pos += 1
		switch x := len(value.KeyId); {
		case x <= 0xfc:
			buf[pos] = byte(x)
			pos += 1
		case x <= 0xffff:
			buf[pos] = 0xfd
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 0xfe
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 0xff
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
		copy(buf[pos:], value.KeyId)
		pos += uint(len(value.KeyId))
	}
	if value.Iv != nil {
		buf[pos] = byte(132)
		pos += 1
		switch x := len(value.Iv); {
		case x <= 0xfc:
			buf[pos] = byte(x)
			pos += 1
		case x <= 0xffff:
			buf[pos] = 0xfd
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 0xfe
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 0xff
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
		copy(buf[pos:], value.Iv)
		pos += uint(len(value.Iv))
	}
	buf[pos] = byte(134)
	pos += 1
	switch x := value.ContentLength; {
	case x <= 0xff:
		buf[pos] = 1
		buf[pos+1] = byte(x)
		pos += 2
	case x <= 0xffff:
		buf[pos] = 2
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 4
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 8
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
	if value.CipherText != nil {
		buf[pos] = byte(136)
		pos += 1
		switch x := encoder.CipherText_length; {
		case x <= 0xfc:
			buf[pos] = byte(x)
			pos += 1
		case x <= 0xffff:
			buf[pos] = 0xfd
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 0xfe
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 0xff
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
		wireIdx++
		pos = 0
		if wireIdx < len(wire) {
			buf = wire[wireIdx]
		} else {
			buf = nil
		}
		for _, w := range value.CipherText {
			wire[wireIdx] = w
			wireIdx++
			pos = 0
			if wireIdx < len(wire) {
				buf = wire[wireIdx]
			} else {
				buf = nil
			}
		}
	}
}

func (encoder *EncryptedContentEncoder) Encode(value *EncryptedContent) enc.Wire {

	wire := make(enc.Wire, len(encoder.wirePlan))
	for i, l := range encoder.wirePlan {
		if l > 0 {
			wire[i] = make([]byte, l)
		}
	}
	encoder.EncodeInto(value, wire)

	return wire
}

func (context *EncryptedContentParsingContext) Parse(reader enc.ParseReader, ignoreCritical bool) (*EncryptedContent, error) {
	if reader == nil {
		return nil, enc.ErrBufferOverflow
	}

	var handled_KeyId bool = false
	var handled_Iv bool = false
	var handled_ContentLength bool = false
	var handled_CipherText bool = false

	progress := -1
	_ = progress

	value := &EncryptedContent{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 130:
				if true {
					handled = true
					handled_KeyId = true
					value.KeyId = make([]byte, l)
					_, err = io.ReadFull(reader, value.KeyId)
				}
			case 132:
				if true {
					handled = true
					handled_Iv = true
					value.Iv = make([]byte, l)
					_, err = io.ReadFull(reader, value.Iv)
				}
			case 134:
				if true {
					handled = true
					handled_ContentLength = true
					value.ContentLength = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.ContentLength = uint64(value.ContentLength<<8) | uint64(x)
						}
					}
				}
			case 136:
				if true {
					handled = true
					handled_CipherText = true
					value.CipherText, err = reader.ReadWire(int(l))
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_KeyId && err == nil {
		value.KeyId = nil
	}
	if !handled_Iv && err == nil {
		value.Iv = nil
	}
	if !handled_ContentLength && err == nil {
		err = enc.ErrSkipRequired{Name: "ContentLength", TypeNum: 134}
	}
	if !handled_CipherText && err == nil {
		value.CipherText = nil
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *EncryptedContent) Encode() enc.Wire {
	encoder := EncryptedContentEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *EncryptedContent) Bytes() []byte {
	return value.Encode().Join()
}

func ParseEncryptedContent(reader enc.ParseReader, ignoreCritical bool) (*EncryptedContent, error) {
	context := EncryptedContentParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}
