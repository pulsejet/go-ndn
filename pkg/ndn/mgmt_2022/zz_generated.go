// @generated by the gondn_tlv_gen, DO NOT modify manually
package mgmt_2022

import (
	"encoding/binary"
	"io"
	"strings"

	enc "github.com/zjkmxy/go-ndn/pkg/encoding"
)

type StrategyEncoder struct {
	length uint

	Name_length uint
}

type StrategyParsingContext struct {
}

func (encoder *StrategyEncoder) Init(value *Strategy) {
	if value.Name != nil {
		encoder.Name_length = 0
		for _, c := range value.Name {
			encoder.Name_length += uint(c.EncodingLength())
		}
	}

	l := uint(0)
	if value.Name != nil {
		l += 1
		switch x := encoder.Name_length; {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		l += encoder.Name_length
	}
	encoder.length = l

}

func (context *StrategyParsingContext) Init() {

}

func (encoder *StrategyEncoder) EncodeInto(value *Strategy, buf []byte) {

	pos := uint(0)

	if value.Name != nil {
		buf[pos] = byte(7)
		pos += 1
		switch x := encoder.Name_length; {
		case x <= 0xfc:
			buf[pos] = byte(x)
			pos += 1
		case x <= 0xffff:
			buf[pos] = 0xfd
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 0xfe
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 0xff
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
		for _, c := range value.Name {
			pos += uint(c.EncodeInto(buf[pos:]))
		}
	}
}

func (encoder *StrategyEncoder) Encode(value *Strategy) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *StrategyParsingContext) Parse(reader enc.ParseReader, ignoreCritical bool) (*Strategy, error) {
	if reader == nil {
		return nil, enc.ErrBufferOverflow
	}

	var handled_Name bool = false

	progress := -1
	_ = progress

	value := &Strategy{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 7:
				if true {
					handled = true
					handled_Name = true
					value.Name = make(enc.Name, l/2+1)
					startName := reader.Pos()
					endName := startName + int(l)
					for j := range value.Name {
						if reader.Pos() >= endName {
							value.Name = value.Name[:j]
							break
						}
						var err1, err3 error
						value.Name[j].Typ, err1 = enc.ReadTLNum(reader)
						l, err2 := enc.ReadTLNum(reader)
						value.Name[j].Val, err3 = reader.ReadBuf(int(l))
						if err1 != nil || err2 != nil || err3 != nil {
							err = io.ErrUnexpectedEOF
							break
						}
					}
					if err == nil && reader.Pos() != endName {
						err = enc.ErrBufferOverflow
					}
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Name && err == nil {
		value.Name = nil
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *Strategy) Encode() enc.Wire {
	encoder := StrategyEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *Strategy) Bytes() []byte {
	return value.Encode().Join()
}

func ParseStrategy(reader enc.ParseReader, ignoreCritical bool) (*Strategy, error) {
	context := StrategyParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

func (value *Strategy) ToDict() map[string]any {
	dict := map[string]any{}
	if value.Name != nil {
		dict["Name"] = value.Name
	}
	return dict
}

func DictToStrategy(dict map[string]any) (*Strategy, error) {
	value := &Strategy{}
	var err error = nil
	if vv, ok := dict["Name"]; ok {
		if v, ok := vv.(enc.Name); ok {
			value.Name = v
		} else {
			err = enc.ErrIncompatibleType{Name: "Name", TypeNum: 7, ValType: "Name", Value: vv}
		}
	} else {
		value.Name = nil
	}
	if err != nil {
		return nil, err
	}
	return value, nil
}

type ControlArgsEncoder struct {
	length uint

	Name_length uint

	Strategy_encoder StrategyEncoder
}

type ControlArgsParsingContext struct {
	Strategy_context StrategyParsingContext
}

func (encoder *ControlArgsEncoder) Init(value *ControlArgs) {
	if value.Name != nil {
		encoder.Name_length = 0
		for _, c := range value.Name {
			encoder.Name_length += uint(c.EncodingLength())
		}
	}

	if value.Strategy != nil {
		encoder.Strategy_encoder.Init(value.Strategy)
	}

	l := uint(0)
	if value.Name != nil {
		l += 1
		switch x := encoder.Name_length; {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		l += encoder.Name_length
	}
	if value.FaceId != nil {
		l += 1
		switch x := *value.FaceId; {
		case x <= 0xff:
			l += 2
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
	}
	if value.Uri != nil {
		l += 1
		switch x := len(*value.Uri); {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		l += uint(len(*value.Uri))
	}
	if value.LocalUri != nil {
		l += 1
		switch x := len(*value.LocalUri); {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		l += uint(len(*value.LocalUri))
	}
	if value.Origin != nil {
		l += 1
		switch x := *value.Origin; {
		case x <= 0xff:
			l += 2
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
	}
	if value.Cost != nil {
		l += 1
		switch x := *value.Cost; {
		case x <= 0xff:
			l += 2
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
	}
	if value.Capacity != nil {
		l += 1
		switch x := *value.Capacity; {
		case x <= 0xff:
			l += 2
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
	}
	if value.Count != nil {
		l += 1
		switch x := *value.Count; {
		case x <= 0xff:
			l += 2
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
	}
	if value.Flags != nil {
		l += 1
		switch x := *value.Flags; {
		case x <= 0xff:
			l += 2
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
	}
	if value.Mask != nil {
		l += 1
		switch x := *value.Mask; {
		case x <= 0xff:
			l += 2
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
	}
	if value.Strategy != nil {
		l += 1
		switch x := encoder.Strategy_encoder.length; {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		l += encoder.Strategy_encoder.length
	}
	if value.ExpirationPeriod != nil {
		l += 1
		switch x := *value.ExpirationPeriod; {
		case x <= 0xff:
			l += 2
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
	}
	if value.FacePersistency != nil {
		l += 1
		switch x := *value.FacePersistency; {
		case x <= 0xff:
			l += 2
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
	}
	if value.BaseCongestionMarkInterval != nil {
		l += 1
		switch x := *value.BaseCongestionMarkInterval; {
		case x <= 0xff:
			l += 2
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
	}
	if value.DefaultCongestionThreshold != nil {
		l += 1
		switch x := *value.DefaultCongestionThreshold; {
		case x <= 0xff:
			l += 2
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
	}
	if value.Mtu != nil {
		l += 1
		switch x := *value.Mtu; {
		case x <= 0xff:
			l += 2
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
	}
	encoder.length = l

}

func (context *ControlArgsParsingContext) Init() {

	context.Strategy_context.Init()

}

func (encoder *ControlArgsEncoder) EncodeInto(value *ControlArgs, buf []byte) {

	pos := uint(0)

	if value.Name != nil {
		buf[pos] = byte(7)
		pos += 1
		switch x := encoder.Name_length; {
		case x <= 0xfc:
			buf[pos] = byte(x)
			pos += 1
		case x <= 0xffff:
			buf[pos] = 0xfd
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 0xfe
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 0xff
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
		for _, c := range value.Name {
			pos += uint(c.EncodeInto(buf[pos:]))
		}
	}
	if value.FaceId != nil {
		buf[pos] = byte(105)
		pos += 1
		switch x := *value.FaceId; {
		case x <= 0xff:
			buf[pos] = 1
			buf[pos+1] = byte(x)
			pos += 2
		case x <= 0xffff:
			buf[pos] = 2
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 4
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 8
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
	}
	if value.Uri != nil {
		buf[pos] = byte(114)
		pos += 1
		switch x := len(*value.Uri); {
		case x <= 0xfc:
			buf[pos] = byte(x)
			pos += 1
		case x <= 0xffff:
			buf[pos] = 0xfd
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 0xfe
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 0xff
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
		copy(buf[pos:], *value.Uri)
		pos += uint(len(*value.Uri))
	}
	if value.LocalUri != nil {
		buf[pos] = byte(129)
		pos += 1
		switch x := len(*value.LocalUri); {
		case x <= 0xfc:
			buf[pos] = byte(x)
			pos += 1
		case x <= 0xffff:
			buf[pos] = 0xfd
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 0xfe
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 0xff
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
		copy(buf[pos:], *value.LocalUri)
		pos += uint(len(*value.LocalUri))
	}
	if value.Origin != nil {
		buf[pos] = byte(111)
		pos += 1
		switch x := *value.Origin; {
		case x <= 0xff:
			buf[pos] = 1
			buf[pos+1] = byte(x)
			pos += 2
		case x <= 0xffff:
			buf[pos] = 2
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 4
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 8
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
	}
	if value.Cost != nil {
		buf[pos] = byte(106)
		pos += 1
		switch x := *value.Cost; {
		case x <= 0xff:
			buf[pos] = 1
			buf[pos+1] = byte(x)
			pos += 2
		case x <= 0xffff:
			buf[pos] = 2
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 4
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 8
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
	}
	if value.Capacity != nil {
		buf[pos] = byte(131)
		pos += 1
		switch x := *value.Capacity; {
		case x <= 0xff:
			buf[pos] = 1
			buf[pos+1] = byte(x)
			pos += 2
		case x <= 0xffff:
			buf[pos] = 2
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 4
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 8
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
	}
	if value.Count != nil {
		buf[pos] = byte(132)
		pos += 1
		switch x := *value.Count; {
		case x <= 0xff:
			buf[pos] = 1
			buf[pos+1] = byte(x)
			pos += 2
		case x <= 0xffff:
			buf[pos] = 2
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 4
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 8
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
	}
	if value.Flags != nil {
		buf[pos] = byte(108)
		pos += 1
		switch x := *value.Flags; {
		case x <= 0xff:
			buf[pos] = 1
			buf[pos+1] = byte(x)
			pos += 2
		case x <= 0xffff:
			buf[pos] = 2
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 4
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 8
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
	}
	if value.Mask != nil {
		buf[pos] = byte(112)
		pos += 1
		switch x := *value.Mask; {
		case x <= 0xff:
			buf[pos] = 1
			buf[pos+1] = byte(x)
			pos += 2
		case x <= 0xffff:
			buf[pos] = 2
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 4
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 8
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
	}
	if value.Strategy != nil {
		buf[pos] = byte(107)
		pos += 1
		switch x := encoder.Strategy_encoder.length; {
		case x <= 0xfc:
			buf[pos] = byte(x)
			pos += 1
		case x <= 0xffff:
			buf[pos] = 0xfd
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 0xfe
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 0xff
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
		if encoder.Strategy_encoder.length > 0 {
			encoder.Strategy_encoder.EncodeInto(value.Strategy, buf[pos:])
			pos += encoder.Strategy_encoder.length
		}
	}
	if value.ExpirationPeriod != nil {
		buf[pos] = byte(109)
		pos += 1
		switch x := *value.ExpirationPeriod; {
		case x <= 0xff:
			buf[pos] = 1
			buf[pos+1] = byte(x)
			pos += 2
		case x <= 0xffff:
			buf[pos] = 2
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 4
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 8
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
	}
	if value.FacePersistency != nil {
		buf[pos] = byte(133)
		pos += 1
		switch x := *value.FacePersistency; {
		case x <= 0xff:
			buf[pos] = 1
			buf[pos+1] = byte(x)
			pos += 2
		case x <= 0xffff:
			buf[pos] = 2
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 4
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 8
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
	}
	if value.BaseCongestionMarkInterval != nil {
		buf[pos] = byte(135)
		pos += 1
		switch x := *value.BaseCongestionMarkInterval; {
		case x <= 0xff:
			buf[pos] = 1
			buf[pos+1] = byte(x)
			pos += 2
		case x <= 0xffff:
			buf[pos] = 2
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 4
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 8
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
	}
	if value.DefaultCongestionThreshold != nil {
		buf[pos] = byte(136)
		pos += 1
		switch x := *value.DefaultCongestionThreshold; {
		case x <= 0xff:
			buf[pos] = 1
			buf[pos+1] = byte(x)
			pos += 2
		case x <= 0xffff:
			buf[pos] = 2
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 4
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 8
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
	}
	if value.Mtu != nil {
		buf[pos] = byte(137)
		pos += 1
		switch x := *value.Mtu; {
		case x <= 0xff:
			buf[pos] = 1
			buf[pos+1] = byte(x)
			pos += 2
		case x <= 0xffff:
			buf[pos] = 2
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 4
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 8
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
	}
}

func (encoder *ControlArgsEncoder) Encode(value *ControlArgs) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *ControlArgsParsingContext) Parse(reader enc.ParseReader, ignoreCritical bool) (*ControlArgs, error) {
	if reader == nil {
		return nil, enc.ErrBufferOverflow
	}

	var handled_Name bool = false
	var handled_FaceId bool = false
	var handled_Uri bool = false
	var handled_LocalUri bool = false
	var handled_Origin bool = false
	var handled_Cost bool = false
	var handled_Capacity bool = false
	var handled_Count bool = false
	var handled_Flags bool = false
	var handled_Mask bool = false
	var handled_Strategy bool = false
	var handled_ExpirationPeriod bool = false
	var handled_FacePersistency bool = false
	var handled_BaseCongestionMarkInterval bool = false
	var handled_DefaultCongestionThreshold bool = false
	var handled_Mtu bool = false

	progress := -1
	_ = progress

	value := &ControlArgs{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 7:
				if true {
					handled = true
					handled_Name = true
					value.Name = make(enc.Name, l/2+1)
					startName := reader.Pos()
					endName := startName + int(l)
					for j := range value.Name {
						if reader.Pos() >= endName {
							value.Name = value.Name[:j]
							break
						}
						var err1, err3 error
						value.Name[j].Typ, err1 = enc.ReadTLNum(reader)
						l, err2 := enc.ReadTLNum(reader)
						value.Name[j].Val, err3 = reader.ReadBuf(int(l))
						if err1 != nil || err2 != nil || err3 != nil {
							err = io.ErrUnexpectedEOF
							break
						}
					}
					if err == nil && reader.Pos() != endName {
						err = enc.ErrBufferOverflow
					}
				}
			case 105:
				if true {
					handled = true
					handled_FaceId = true
					{
						tempVal := uint64(0)
						tempVal = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								tempVal = uint64(tempVal<<8) | uint64(x)
							}
						}
						value.FaceId = &tempVal
					}
				}
			case 114:
				if true {
					handled = true
					handled_Uri = true
					{
						var builder strings.Builder
						_, err = io.CopyN(&builder, reader, int64(l))
						if err == nil {
							tempStr := builder.String()
							value.Uri = &tempStr
						}
					}
				}
			case 129:
				if true {
					handled = true
					handled_LocalUri = true
					{
						var builder strings.Builder
						_, err = io.CopyN(&builder, reader, int64(l))
						if err == nil {
							tempStr := builder.String()
							value.LocalUri = &tempStr
						}
					}
				}
			case 111:
				if true {
					handled = true
					handled_Origin = true
					{
						tempVal := uint64(0)
						tempVal = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								tempVal = uint64(tempVal<<8) | uint64(x)
							}
						}
						value.Origin = &tempVal
					}
				}
			case 106:
				if true {
					handled = true
					handled_Cost = true
					{
						tempVal := uint64(0)
						tempVal = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								tempVal = uint64(tempVal<<8) | uint64(x)
							}
						}
						value.Cost = &tempVal
					}
				}
			case 131:
				if true {
					handled = true
					handled_Capacity = true
					{
						tempVal := uint64(0)
						tempVal = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								tempVal = uint64(tempVal<<8) | uint64(x)
							}
						}
						value.Capacity = &tempVal
					}
				}
			case 132:
				if true {
					handled = true
					handled_Count = true
					{
						tempVal := uint64(0)
						tempVal = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								tempVal = uint64(tempVal<<8) | uint64(x)
							}
						}
						value.Count = &tempVal
					}
				}
			case 108:
				if true {
					handled = true
					handled_Flags = true
					{
						tempVal := uint64(0)
						tempVal = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								tempVal = uint64(tempVal<<8) | uint64(x)
							}
						}
						value.Flags = &tempVal
					}
				}
			case 112:
				if true {
					handled = true
					handled_Mask = true
					{
						tempVal := uint64(0)
						tempVal = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								tempVal = uint64(tempVal<<8) | uint64(x)
							}
						}
						value.Mask = &tempVal
					}
				}
			case 107:
				if true {
					handled = true
					handled_Strategy = true
					value.Strategy, err = context.Strategy_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			case 109:
				if true {
					handled = true
					handled_ExpirationPeriod = true
					{
						tempVal := uint64(0)
						tempVal = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								tempVal = uint64(tempVal<<8) | uint64(x)
							}
						}
						value.ExpirationPeriod = &tempVal
					}
				}
			case 133:
				if true {
					handled = true
					handled_FacePersistency = true
					{
						tempVal := uint64(0)
						tempVal = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								tempVal = uint64(tempVal<<8) | uint64(x)
							}
						}
						value.FacePersistency = &tempVal
					}
				}
			case 135:
				if true {
					handled = true
					handled_BaseCongestionMarkInterval = true
					{
						tempVal := uint64(0)
						tempVal = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								tempVal = uint64(tempVal<<8) | uint64(x)
							}
						}
						value.BaseCongestionMarkInterval = &tempVal
					}
				}
			case 136:
				if true {
					handled = true
					handled_DefaultCongestionThreshold = true
					{
						tempVal := uint64(0)
						tempVal = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								tempVal = uint64(tempVal<<8) | uint64(x)
							}
						}
						value.DefaultCongestionThreshold = &tempVal
					}
				}
			case 137:
				if true {
					handled = true
					handled_Mtu = true
					{
						tempVal := uint64(0)
						tempVal = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								tempVal = uint64(tempVal<<8) | uint64(x)
							}
						}
						value.Mtu = &tempVal
					}
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Name && err == nil {
		value.Name = nil
	}
	if !handled_FaceId && err == nil {
		value.FaceId = nil
	}
	if !handled_Uri && err == nil {
		value.Uri = nil
	}
	if !handled_LocalUri && err == nil {
		value.LocalUri = nil
	}
	if !handled_Origin && err == nil {
		value.Origin = nil
	}
	if !handled_Cost && err == nil {
		value.Cost = nil
	}
	if !handled_Capacity && err == nil {
		value.Capacity = nil
	}
	if !handled_Count && err == nil {
		value.Count = nil
	}
	if !handled_Flags && err == nil {
		value.Flags = nil
	}
	if !handled_Mask && err == nil {
		value.Mask = nil
	}
	if !handled_Strategy && err == nil {
		value.Strategy = nil
	}
	if !handled_ExpirationPeriod && err == nil {
		value.ExpirationPeriod = nil
	}
	if !handled_FacePersistency && err == nil {
		value.FacePersistency = nil
	}
	if !handled_BaseCongestionMarkInterval && err == nil {
		value.BaseCongestionMarkInterval = nil
	}
	if !handled_DefaultCongestionThreshold && err == nil {
		value.DefaultCongestionThreshold = nil
	}
	if !handled_Mtu && err == nil {
		value.Mtu = nil
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *ControlArgs) Encode() enc.Wire {
	encoder := ControlArgsEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *ControlArgs) Bytes() []byte {
	return value.Encode().Join()
}

func ParseControlArgs(reader enc.ParseReader, ignoreCritical bool) (*ControlArgs, error) {
	context := ControlArgsParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

func (value *ControlArgs) ToDict() map[string]any {
	dict := map[string]any{}
	if value.Name != nil {
		dict["Name"] = value.Name
	}
	if value.FaceId != nil {
		dict["FaceId"] = *value.FaceId
	}
	if value.Uri != nil {
		dict["Uri"] = *value.Uri
	}
	if value.LocalUri != nil {
		dict["LocalUri"] = *value.LocalUri
	}
	if value.Origin != nil {
		dict["Origin"] = *value.Origin
	}
	if value.Cost != nil {
		dict["Cost"] = *value.Cost
	}
	if value.Capacity != nil {
		dict["Capacity"] = *value.Capacity
	}
	if value.Count != nil {
		dict["Count"] = *value.Count
	}
	if value.Flags != nil {
		dict["Flags"] = *value.Flags
	}
	if value.Mask != nil {
		dict["Mask"] = *value.Mask
	}
	if value.Strategy != nil {
		dict["Strategy"] = value.Strategy.ToDict()
	}
	if value.ExpirationPeriod != nil {
		dict["ExpirationPeriod"] = *value.ExpirationPeriod
	}
	if value.FacePersistency != nil {
		dict["FacePersistency"] = *value.FacePersistency
	}
	if value.BaseCongestionMarkInterval != nil {
		dict["BaseCongestionMarkInterval"] = *value.BaseCongestionMarkInterval
	}
	if value.DefaultCongestionThreshold != nil {
		dict["DefaultCongestionThreshold"] = *value.DefaultCongestionThreshold
	}
	if value.Mtu != nil {
		dict["Mtu"] = *value.Mtu
	}
	return dict
}

func DictToControlArgs(dict map[string]any) (*ControlArgs, error) {
	value := &ControlArgs{}
	var err error = nil
	if vv, ok := dict["Name"]; ok {
		if v, ok := vv.(enc.Name); ok {
			value.Name = v
		} else {
			err = enc.ErrIncompatibleType{Name: "Name", TypeNum: 7, ValType: "Name", Value: vv}
		}
	} else {
		value.Name = nil
	}
	if err != nil {
		return nil, err
	}
	if vv, ok := dict["FaceId"]; ok {
		if v, ok := vv.(uint64); ok {
			value.FaceId = &v
		} else {
			err = enc.ErrIncompatibleType{Name: "FaceId", TypeNum: 105, ValType: "uint64", Value: vv}
		}
	} else {
		value.FaceId = nil
	}
	if err != nil {
		return nil, err
	}
	if vv, ok := dict["Uri"]; ok {
		if v, ok := vv.(string); ok {
			value.Uri = &v
		} else {
			err = enc.ErrIncompatibleType{Name: "Uri", TypeNum: 114, ValType: "string", Value: vv}
		}
	} else {
		value.Uri = nil
	}
	if err != nil {
		return nil, err
	}
	if vv, ok := dict["LocalUri"]; ok {
		if v, ok := vv.(string); ok {
			value.LocalUri = &v
		} else {
			err = enc.ErrIncompatibleType{Name: "LocalUri", TypeNum: 129, ValType: "string", Value: vv}
		}
	} else {
		value.LocalUri = nil
	}
	if err != nil {
		return nil, err
	}
	if vv, ok := dict["Origin"]; ok {
		if v, ok := vv.(uint64); ok {
			value.Origin = &v
		} else {
			err = enc.ErrIncompatibleType{Name: "Origin", TypeNum: 111, ValType: "uint64", Value: vv}
		}
	} else {
		value.Origin = nil
	}
	if err != nil {
		return nil, err
	}
	if vv, ok := dict["Cost"]; ok {
		if v, ok := vv.(uint64); ok {
			value.Cost = &v
		} else {
			err = enc.ErrIncompatibleType{Name: "Cost", TypeNum: 106, ValType: "uint64", Value: vv}
		}
	} else {
		value.Cost = nil
	}
	if err != nil {
		return nil, err
	}
	if vv, ok := dict["Capacity"]; ok {
		if v, ok := vv.(uint64); ok {
			value.Capacity = &v
		} else {
			err = enc.ErrIncompatibleType{Name: "Capacity", TypeNum: 131, ValType: "uint64", Value: vv}
		}
	} else {
		value.Capacity = nil
	}
	if err != nil {
		return nil, err
	}
	if vv, ok := dict["Count"]; ok {
		if v, ok := vv.(uint64); ok {
			value.Count = &v
		} else {
			err = enc.ErrIncompatibleType{Name: "Count", TypeNum: 132, ValType: "uint64", Value: vv}
		}
	} else {
		value.Count = nil
	}
	if err != nil {
		return nil, err
	}
	if vv, ok := dict["Flags"]; ok {
		if v, ok := vv.(uint64); ok {
			value.Flags = &v
		} else {
			err = enc.ErrIncompatibleType{Name: "Flags", TypeNum: 108, ValType: "uint64", Value: vv}
		}
	} else {
		value.Flags = nil
	}
	if err != nil {
		return nil, err
	}
	if vv, ok := dict["Mask"]; ok {
		if v, ok := vv.(uint64); ok {
			value.Mask = &v
		} else {
			err = enc.ErrIncompatibleType{Name: "Mask", TypeNum: 112, ValType: "uint64", Value: vv}
		}
	} else {
		value.Mask = nil
	}
	if err != nil {
		return nil, err
	}
	if vv, ok := dict["Strategy"]; ok {
		if v, ok := vv.(*Strategy); ok {
			value.Strategy = v
		} else {
			err = enc.ErrIncompatibleType{Name: "Strategy", TypeNum: 107, ValType: "*Strategy", Value: vv}
		}
	} else {
		value.Strategy = nil
	}
	if err != nil {
		return nil, err
	}
	if vv, ok := dict["ExpirationPeriod"]; ok {
		if v, ok := vv.(uint64); ok {
			value.ExpirationPeriod = &v
		} else {
			err = enc.ErrIncompatibleType{Name: "ExpirationPeriod", TypeNum: 109, ValType: "uint64", Value: vv}
		}
	} else {
		value.ExpirationPeriod = nil
	}
	if err != nil {
		return nil, err
	}
	if vv, ok := dict["FacePersistency"]; ok {
		if v, ok := vv.(uint64); ok {
			value.FacePersistency = &v
		} else {
			err = enc.ErrIncompatibleType{Name: "FacePersistency", TypeNum: 133, ValType: "uint64", Value: vv}
		}
	} else {
		value.FacePersistency = nil
	}
	if err != nil {
		return nil, err
	}
	if vv, ok := dict["BaseCongestionMarkInterval"]; ok {
		if v, ok := vv.(uint64); ok {
			value.BaseCongestionMarkInterval = &v
		} else {
			err = enc.ErrIncompatibleType{Name: "BaseCongestionMarkInterval", TypeNum: 135, ValType: "uint64", Value: vv}
		}
	} else {
		value.BaseCongestionMarkInterval = nil
	}
	if err != nil {
		return nil, err
	}
	if vv, ok := dict["DefaultCongestionThreshold"]; ok {
		if v, ok := vv.(uint64); ok {
			value.DefaultCongestionThreshold = &v
		} else {
			err = enc.ErrIncompatibleType{Name: "DefaultCongestionThreshold", TypeNum: 136, ValType: "uint64", Value: vv}
		}
	} else {
		value.DefaultCongestionThreshold = nil
	}
	if err != nil {
		return nil, err
	}
	if vv, ok := dict["Mtu"]; ok {
		if v, ok := vv.(uint64); ok {
			value.Mtu = &v
		} else {
			err = enc.ErrIncompatibleType{Name: "Mtu", TypeNum: 137, ValType: "uint64", Value: vv}
		}
	} else {
		value.Mtu = nil
	}
	if err != nil {
		return nil, err
	}
	return value, nil
}

type ControlResponseValEncoder struct {
	length uint

	Params_encoder ControlArgsEncoder
}

type ControlResponseValParsingContext struct {
	Params_context ControlArgsParsingContext
}

func (encoder *ControlResponseValEncoder) Init(value *ControlResponseVal) {

	if value.Params != nil {
		encoder.Params_encoder.Init(value.Params)
	}

	l := uint(0)
	l += 1
	switch x := value.StatusCode; {
	case x <= 0xff:
		l += 2
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	l += 1
	switch x := len(value.StatusText); {
	case x <= 0xfc:
		l += 1
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	l += uint(len(value.StatusText))
	if value.Params != nil {
		l += 1
		switch x := encoder.Params_encoder.length; {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		l += encoder.Params_encoder.length
	}
	encoder.length = l

}

func (context *ControlResponseValParsingContext) Init() {

	context.Params_context.Init()
}

func (encoder *ControlResponseValEncoder) EncodeInto(value *ControlResponseVal, buf []byte) {

	pos := uint(0)

	buf[pos] = byte(102)
	pos += 1
	switch x := value.StatusCode; {
	case x <= 0xff:
		buf[pos] = 1
		buf[pos+1] = byte(x)
		pos += 2
	case x <= 0xffff:
		buf[pos] = 2
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 4
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 8
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
	buf[pos] = byte(103)
	pos += 1
	switch x := len(value.StatusText); {
	case x <= 0xfc:
		buf[pos] = byte(x)
		pos += 1
	case x <= 0xffff:
		buf[pos] = 0xfd
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 0xfe
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 0xff
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
	copy(buf[pos:], value.StatusText)
	pos += uint(len(value.StatusText))
	if value.Params != nil {
		buf[pos] = byte(104)
		pos += 1
		switch x := encoder.Params_encoder.length; {
		case x <= 0xfc:
			buf[pos] = byte(x)
			pos += 1
		case x <= 0xffff:
			buf[pos] = 0xfd
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 0xfe
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 0xff
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
		if encoder.Params_encoder.length > 0 {
			encoder.Params_encoder.EncodeInto(value.Params, buf[pos:])
			pos += encoder.Params_encoder.length
		}
	}
}

func (encoder *ControlResponseValEncoder) Encode(value *ControlResponseVal) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *ControlResponseValParsingContext) Parse(reader enc.ParseReader, ignoreCritical bool) (*ControlResponseVal, error) {
	if reader == nil {
		return nil, enc.ErrBufferOverflow
	}

	var handled_StatusCode bool = false
	var handled_StatusText bool = false
	var handled_Params bool = false

	progress := -1
	_ = progress

	value := &ControlResponseVal{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 102:
				if true {
					handled = true
					handled_StatusCode = true
					value.StatusCode = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.StatusCode = uint64(value.StatusCode<<8) | uint64(x)
						}
					}
				}
			case 103:
				if true {
					handled = true
					handled_StatusText = true
					{
						var builder strings.Builder
						_, err = io.CopyN(&builder, reader, int64(l))
						if err == nil {
							value.StatusText = builder.String()
						}
					}
				}
			case 104:
				if true {
					handled = true
					handled_Params = true
					value.Params, err = context.Params_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_StatusCode && err == nil {
		err = enc.ErrSkipRequired{Name: "StatusCode", TypeNum: 102}
	}
	if !handled_StatusText && err == nil {
		err = enc.ErrSkipRequired{Name: "StatusText", TypeNum: 103}
	}
	if !handled_Params && err == nil {
		value.Params = nil
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *ControlResponseVal) Encode() enc.Wire {
	encoder := ControlResponseValEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *ControlResponseVal) Bytes() []byte {
	return value.Encode().Join()
}

func ParseControlResponseVal(reader enc.ParseReader, ignoreCritical bool) (*ControlResponseVal, error) {
	context := ControlResponseValParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

func (value *ControlResponseVal) ToDict() map[string]any {
	dict := map[string]any{}
	dict["StatusCode"] = value.StatusCode
	dict["StatusText"] = value.StatusText
	if value.Params != nil {
		dict["Params"] = value.Params.ToDict()
	}
	return dict
}

func DictToControlResponseVal(dict map[string]any) (*ControlResponseVal, error) {
	value := &ControlResponseVal{}
	var err error = nil
	if vv, ok := dict["StatusCode"]; ok {
		if v, ok := vv.(uint64); ok {
			value.StatusCode = v
		} else {
			err = enc.ErrIncompatibleType{Name: "StatusCode", TypeNum: 102, ValType: "uint64", Value: vv}
		}
	} else {
		err = enc.ErrSkipRequired{Name: "StatusCode", TypeNum: 102}
	}
	if err != nil {
		return nil, err
	}
	if vv, ok := dict["StatusText"]; ok {
		if v, ok := vv.(string); ok {
			value.StatusText = v
		} else {
			err = enc.ErrIncompatibleType{Name: "StatusText", TypeNum: 103, ValType: "string", Value: vv}
		}
	} else {
		err = enc.ErrSkipRequired{Name: "StatusText", TypeNum: 103}
	}
	if err != nil {
		return nil, err
	}
	if vv, ok := dict["Params"]; ok {
		if v, ok := vv.(*ControlArgs); ok {
			value.Params = v
		} else {
			err = enc.ErrIncompatibleType{Name: "Params", TypeNum: 104, ValType: "*ControlArgs", Value: vv}
		}
	} else {
		value.Params = nil
	}
	if err != nil {
		return nil, err
	}
	return value, nil
}

type ControlParametersEncoder struct {
	length uint

	Val_encoder ControlArgsEncoder
}

type ControlParametersParsingContext struct {
	Val_context ControlArgsParsingContext
}

func (encoder *ControlParametersEncoder) Init(value *ControlParameters) {
	if value.Val != nil {
		encoder.Val_encoder.Init(value.Val)
	}

	l := uint(0)
	if value.Val != nil {
		l += 1
		switch x := encoder.Val_encoder.length; {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		l += encoder.Val_encoder.length
	}
	encoder.length = l

}

func (context *ControlParametersParsingContext) Init() {
	context.Val_context.Init()
}

func (encoder *ControlParametersEncoder) EncodeInto(value *ControlParameters, buf []byte) {

	pos := uint(0)

	if value.Val != nil {
		buf[pos] = byte(104)
		pos += 1
		switch x := encoder.Val_encoder.length; {
		case x <= 0xfc:
			buf[pos] = byte(x)
			pos += 1
		case x <= 0xffff:
			buf[pos] = 0xfd
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 0xfe
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 0xff
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
		if encoder.Val_encoder.length > 0 {
			encoder.Val_encoder.EncodeInto(value.Val, buf[pos:])
			pos += encoder.Val_encoder.length
		}
	}
}

func (encoder *ControlParametersEncoder) Encode(value *ControlParameters) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *ControlParametersParsingContext) Parse(reader enc.ParseReader, ignoreCritical bool) (*ControlParameters, error) {
	if reader == nil {
		return nil, enc.ErrBufferOverflow
	}

	var handled_Val bool = false

	progress := -1
	_ = progress

	value := &ControlParameters{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 104:
				if true {
					handled = true
					handled_Val = true
					value.Val, err = context.Val_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Val && err == nil {
		value.Val = nil
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *ControlParameters) Encode() enc.Wire {
	encoder := ControlParametersEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *ControlParameters) Bytes() []byte {
	return value.Encode().Join()
}

func ParseControlParameters(reader enc.ParseReader, ignoreCritical bool) (*ControlParameters, error) {
	context := ControlParametersParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type ControlResponseEncoder struct {
	length uint

	Val_encoder ControlResponseValEncoder
}

type ControlResponseParsingContext struct {
	Val_context ControlResponseValParsingContext
}

func (encoder *ControlResponseEncoder) Init(value *ControlResponse) {
	if value.Val != nil {
		encoder.Val_encoder.Init(value.Val)
	}

	l := uint(0)
	if value.Val != nil {
		l += 1
		switch x := encoder.Val_encoder.length; {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		l += encoder.Val_encoder.length
	}
	encoder.length = l

}

func (context *ControlResponseParsingContext) Init() {
	context.Val_context.Init()
}

func (encoder *ControlResponseEncoder) EncodeInto(value *ControlResponse, buf []byte) {

	pos := uint(0)

	if value.Val != nil {
		buf[pos] = byte(101)
		pos += 1
		switch x := encoder.Val_encoder.length; {
		case x <= 0xfc:
			buf[pos] = byte(x)
			pos += 1
		case x <= 0xffff:
			buf[pos] = 0xfd
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 0xfe
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 0xff
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
		if encoder.Val_encoder.length > 0 {
			encoder.Val_encoder.EncodeInto(value.Val, buf[pos:])
			pos += encoder.Val_encoder.length
		}
	}
}

func (encoder *ControlResponseEncoder) Encode(value *ControlResponse) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *ControlResponseParsingContext) Parse(reader enc.ParseReader, ignoreCritical bool) (*ControlResponse, error) {
	if reader == nil {
		return nil, enc.ErrBufferOverflow
	}

	var handled_Val bool = false

	progress := -1
	_ = progress

	value := &ControlResponse{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 101:
				if true {
					handled = true
					handled_Val = true
					value.Val, err = context.Val_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Val && err == nil {
		value.Val = nil
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *ControlResponse) Encode() enc.Wire {
	encoder := ControlResponseEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *ControlResponse) Bytes() []byte {
	return value.Encode().Join()
}

func ParseControlResponse(reader enc.ParseReader, ignoreCritical bool) (*ControlResponse, error) {
	context := ControlResponseParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type FaceEventNotificationValueEncoder struct {
	length uint
}

type FaceEventNotificationValueParsingContext struct {
}

func (encoder *FaceEventNotificationValueEncoder) Init(value *FaceEventNotificationValue) {

	l := uint(0)
	l += 1
	switch x := value.FaceEventKind; {
	case x <= 0xff:
		l += 2
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	l += 1
	switch x := value.FaceId; {
	case x <= 0xff:
		l += 2
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	l += 1
	switch x := len(value.Uri); {
	case x <= 0xfc:
		l += 1
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	l += uint(len(value.Uri))
	l += 1
	switch x := len(value.LocalUri); {
	case x <= 0xfc:
		l += 1
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	l += uint(len(value.LocalUri))
	l += 1
	switch x := value.FaceScope; {
	case x <= 0xff:
		l += 2
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	l += 1
	switch x := value.FacePersistency; {
	case x <= 0xff:
		l += 2
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	l += 1
	switch x := value.LinkType; {
	case x <= 0xff:
		l += 2
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	l += 1
	switch x := value.Flags; {
	case x <= 0xff:
		l += 2
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	encoder.length = l

}

func (context *FaceEventNotificationValueParsingContext) Init() {

}

func (encoder *FaceEventNotificationValueEncoder) EncodeInto(value *FaceEventNotificationValue, buf []byte) {

	pos := uint(0)

	buf[pos] = byte(193)
	pos += 1
	switch x := value.FaceEventKind; {
	case x <= 0xff:
		buf[pos] = 1
		buf[pos+1] = byte(x)
		pos += 2
	case x <= 0xffff:
		buf[pos] = 2
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 4
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 8
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
	buf[pos] = byte(105)
	pos += 1
	switch x := value.FaceId; {
	case x <= 0xff:
		buf[pos] = 1
		buf[pos+1] = byte(x)
		pos += 2
	case x <= 0xffff:
		buf[pos] = 2
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 4
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 8
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
	buf[pos] = byte(114)
	pos += 1
	switch x := len(value.Uri); {
	case x <= 0xfc:
		buf[pos] = byte(x)
		pos += 1
	case x <= 0xffff:
		buf[pos] = 0xfd
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 0xfe
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 0xff
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
	copy(buf[pos:], value.Uri)
	pos += uint(len(value.Uri))
	buf[pos] = byte(129)
	pos += 1
	switch x := len(value.LocalUri); {
	case x <= 0xfc:
		buf[pos] = byte(x)
		pos += 1
	case x <= 0xffff:
		buf[pos] = 0xfd
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 0xfe
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 0xff
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
	copy(buf[pos:], value.LocalUri)
	pos += uint(len(value.LocalUri))
	buf[pos] = byte(132)
	pos += 1
	switch x := value.FaceScope; {
	case x <= 0xff:
		buf[pos] = 1
		buf[pos+1] = byte(x)
		pos += 2
	case x <= 0xffff:
		buf[pos] = 2
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 4
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 8
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
	buf[pos] = byte(133)
	pos += 1
	switch x := value.FacePersistency; {
	case x <= 0xff:
		buf[pos] = 1
		buf[pos+1] = byte(x)
		pos += 2
	case x <= 0xffff:
		buf[pos] = 2
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 4
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 8
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
	buf[pos] = byte(134)
	pos += 1
	switch x := value.LinkType; {
	case x <= 0xff:
		buf[pos] = 1
		buf[pos+1] = byte(x)
		pos += 2
	case x <= 0xffff:
		buf[pos] = 2
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 4
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 8
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
	buf[pos] = byte(108)
	pos += 1
	switch x := value.Flags; {
	case x <= 0xff:
		buf[pos] = 1
		buf[pos+1] = byte(x)
		pos += 2
	case x <= 0xffff:
		buf[pos] = 2
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 4
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 8
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
}

func (encoder *FaceEventNotificationValueEncoder) Encode(value *FaceEventNotificationValue) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *FaceEventNotificationValueParsingContext) Parse(reader enc.ParseReader, ignoreCritical bool) (*FaceEventNotificationValue, error) {
	if reader == nil {
		return nil, enc.ErrBufferOverflow
	}

	var handled_FaceEventKind bool = false
	var handled_FaceId bool = false
	var handled_Uri bool = false
	var handled_LocalUri bool = false
	var handled_FaceScope bool = false
	var handled_FacePersistency bool = false
	var handled_LinkType bool = false
	var handled_Flags bool = false

	progress := -1
	_ = progress

	value := &FaceEventNotificationValue{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 193:
				if true {
					handled = true
					handled_FaceEventKind = true
					value.FaceEventKind = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.FaceEventKind = uint64(value.FaceEventKind<<8) | uint64(x)
						}
					}
				}
			case 105:
				if true {
					handled = true
					handled_FaceId = true
					value.FaceId = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.FaceId = uint64(value.FaceId<<8) | uint64(x)
						}
					}
				}
			case 114:
				if true {
					handled = true
					handled_Uri = true
					{
						var builder strings.Builder
						_, err = io.CopyN(&builder, reader, int64(l))
						if err == nil {
							value.Uri = builder.String()
						}
					}
				}
			case 129:
				if true {
					handled = true
					handled_LocalUri = true
					{
						var builder strings.Builder
						_, err = io.CopyN(&builder, reader, int64(l))
						if err == nil {
							value.LocalUri = builder.String()
						}
					}
				}
			case 132:
				if true {
					handled = true
					handled_FaceScope = true
					value.FaceScope = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.FaceScope = uint64(value.FaceScope<<8) | uint64(x)
						}
					}
				}
			case 133:
				if true {
					handled = true
					handled_FacePersistency = true
					value.FacePersistency = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.FacePersistency = uint64(value.FacePersistency<<8) | uint64(x)
						}
					}
				}
			case 134:
				if true {
					handled = true
					handled_LinkType = true
					value.LinkType = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.LinkType = uint64(value.LinkType<<8) | uint64(x)
						}
					}
				}
			case 108:
				if true {
					handled = true
					handled_Flags = true
					value.Flags = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.Flags = uint64(value.Flags<<8) | uint64(x)
						}
					}
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_FaceEventKind && err == nil {
		err = enc.ErrSkipRequired{Name: "FaceEventKind", TypeNum: 193}
	}
	if !handled_FaceId && err == nil {
		err = enc.ErrSkipRequired{Name: "FaceId", TypeNum: 105}
	}
	if !handled_Uri && err == nil {
		err = enc.ErrSkipRequired{Name: "Uri", TypeNum: 114}
	}
	if !handled_LocalUri && err == nil {
		err = enc.ErrSkipRequired{Name: "LocalUri", TypeNum: 129}
	}
	if !handled_FaceScope && err == nil {
		err = enc.ErrSkipRequired{Name: "FaceScope", TypeNum: 132}
	}
	if !handled_FacePersistency && err == nil {
		err = enc.ErrSkipRequired{Name: "FacePersistency", TypeNum: 133}
	}
	if !handled_LinkType && err == nil {
		err = enc.ErrSkipRequired{Name: "LinkType", TypeNum: 134}
	}
	if !handled_Flags && err == nil {
		err = enc.ErrSkipRequired{Name: "Flags", TypeNum: 108}
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *FaceEventNotificationValue) Encode() enc.Wire {
	encoder := FaceEventNotificationValueEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *FaceEventNotificationValue) Bytes() []byte {
	return value.Encode().Join()
}

func ParseFaceEventNotificationValue(reader enc.ParseReader, ignoreCritical bool) (*FaceEventNotificationValue, error) {
	context := FaceEventNotificationValueParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type FaceEventNotificationEncoder struct {
	length uint

	Val_encoder FaceEventNotificationValueEncoder
}

type FaceEventNotificationParsingContext struct {
	Val_context FaceEventNotificationValueParsingContext
}

func (encoder *FaceEventNotificationEncoder) Init(value *FaceEventNotification) {
	if value.Val != nil {
		encoder.Val_encoder.Init(value.Val)
	}

	l := uint(0)
	if value.Val != nil {
		l += 1
		switch x := encoder.Val_encoder.length; {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		l += encoder.Val_encoder.length
	}
	encoder.length = l

}

func (context *FaceEventNotificationParsingContext) Init() {
	context.Val_context.Init()
}

func (encoder *FaceEventNotificationEncoder) EncodeInto(value *FaceEventNotification, buf []byte) {

	pos := uint(0)

	if value.Val != nil {
		buf[pos] = byte(192)
		pos += 1
		switch x := encoder.Val_encoder.length; {
		case x <= 0xfc:
			buf[pos] = byte(x)
			pos += 1
		case x <= 0xffff:
			buf[pos] = 0xfd
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 0xfe
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 0xff
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
		if encoder.Val_encoder.length > 0 {
			encoder.Val_encoder.EncodeInto(value.Val, buf[pos:])
			pos += encoder.Val_encoder.length
		}
	}
}

func (encoder *FaceEventNotificationEncoder) Encode(value *FaceEventNotification) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *FaceEventNotificationParsingContext) Parse(reader enc.ParseReader, ignoreCritical bool) (*FaceEventNotification, error) {
	if reader == nil {
		return nil, enc.ErrBufferOverflow
	}

	var handled_Val bool = false

	progress := -1
	_ = progress

	value := &FaceEventNotification{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 192:
				if true {
					handled = true
					handled_Val = true
					value.Val, err = context.Val_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Val && err == nil {
		value.Val = nil
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *FaceEventNotification) Encode() enc.Wire {
	encoder := FaceEventNotificationEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *FaceEventNotification) Bytes() []byte {
	return value.Encode().Join()
}

func ParseFaceEventNotification(reader enc.ParseReader, ignoreCritical bool) (*FaceEventNotification, error) {
	context := FaceEventNotificationParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type GeneralStatusEncoder struct {
	length uint
}

type GeneralStatusParsingContext struct {
}

func (encoder *GeneralStatusEncoder) Init(value *GeneralStatus) {

	l := uint(0)
	l += 1
	switch x := len(value.NfdVersion); {
	case x <= 0xfc:
		l += 1
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	l += uint(len(value.NfdVersion))
	l += 1
	switch x := value.StartTimestamp; {
	case x <= 0xff:
		l += 2
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	l += 1
	switch x := value.CurrentTimestamp; {
	case x <= 0xff:
		l += 2
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	l += 1
	switch x := value.NNameTreeEntries; {
	case x <= 0xff:
		l += 2
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	l += 1
	switch x := value.NFibEntries; {
	case x <= 0xff:
		l += 2
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	l += 1
	switch x := value.NPitEntries; {
	case x <= 0xff:
		l += 2
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	l += 1
	switch x := value.NMeasurementsEntries; {
	case x <= 0xff:
		l += 2
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	l += 1
	switch x := value.NCsEntries; {
	case x <= 0xff:
		l += 2
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	l += 1
	switch x := value.NInInterests; {
	case x <= 0xff:
		l += 2
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	l += 1
	switch x := value.NInData; {
	case x <= 0xff:
		l += 2
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	l += 1
	switch x := value.NInNacks; {
	case x <= 0xff:
		l += 2
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	l += 1
	switch x := value.NOutInterests; {
	case x <= 0xff:
		l += 2
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	l += 1
	switch x := value.NOutData; {
	case x <= 0xff:
		l += 2
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	l += 1
	switch x := value.NOutNacks; {
	case x <= 0xff:
		l += 2
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	l += 1
	switch x := value.NSatisfiedInterests; {
	case x <= 0xff:
		l += 2
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	l += 1
	switch x := value.NUnsatisfiedInterests; {
	case x <= 0xff:
		l += 2
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	if value.NFragmentationError != nil {
		l += 1
		switch x := *value.NFragmentationError; {
		case x <= 0xff:
			l += 2
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
	}
	if value.NOutOverMtu != nil {
		l += 1
		switch x := *value.NOutOverMtu; {
		case x <= 0xff:
			l += 2
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
	}
	if value.NInLpInvalid != nil {
		l += 1
		switch x := *value.NInLpInvalid; {
		case x <= 0xff:
			l += 2
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
	}
	if value.NReassemblyTimeouts != nil {
		l += 1
		switch x := *value.NReassemblyTimeouts; {
		case x <= 0xff:
			l += 2
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
	}
	if value.NInNetInvalid != nil {
		l += 1
		switch x := *value.NInNetInvalid; {
		case x <= 0xff:
			l += 2
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
	}
	if value.NAcknowledged != nil {
		l += 1
		switch x := *value.NAcknowledged; {
		case x <= 0xff:
			l += 2
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
	}
	if value.NRetransmitted != nil {
		l += 1
		switch x := *value.NRetransmitted; {
		case x <= 0xff:
			l += 2
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
	}
	if value.NRetxExhausted != nil {
		l += 1
		switch x := *value.NRetxExhausted; {
		case x <= 0xff:
			l += 2
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
	}
	if value.NConngestionMarked != nil {
		l += 1
		switch x := *value.NConngestionMarked; {
		case x <= 0xff:
			l += 2
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
	}
	encoder.length = l

}

func (context *GeneralStatusParsingContext) Init() {

}

func (encoder *GeneralStatusEncoder) EncodeInto(value *GeneralStatus, buf []byte) {

	pos := uint(0)

	buf[pos] = byte(128)
	pos += 1
	switch x := len(value.NfdVersion); {
	case x <= 0xfc:
		buf[pos] = byte(x)
		pos += 1
	case x <= 0xffff:
		buf[pos] = 0xfd
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 0xfe
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 0xff
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
	copy(buf[pos:], value.NfdVersion)
	pos += uint(len(value.NfdVersion))
	buf[pos] = byte(129)
	pos += 1
	switch x := value.StartTimestamp; {
	case x <= 0xff:
		buf[pos] = 1
		buf[pos+1] = byte(x)
		pos += 2
	case x <= 0xffff:
		buf[pos] = 2
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 4
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 8
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
	buf[pos] = byte(130)
	pos += 1
	switch x := value.CurrentTimestamp; {
	case x <= 0xff:
		buf[pos] = 1
		buf[pos+1] = byte(x)
		pos += 2
	case x <= 0xffff:
		buf[pos] = 2
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 4
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 8
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
	buf[pos] = byte(131)
	pos += 1
	switch x := value.NNameTreeEntries; {
	case x <= 0xff:
		buf[pos] = 1
		buf[pos+1] = byte(x)
		pos += 2
	case x <= 0xffff:
		buf[pos] = 2
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 4
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 8
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
	buf[pos] = byte(132)
	pos += 1
	switch x := value.NFibEntries; {
	case x <= 0xff:
		buf[pos] = 1
		buf[pos+1] = byte(x)
		pos += 2
	case x <= 0xffff:
		buf[pos] = 2
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 4
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 8
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
	buf[pos] = byte(133)
	pos += 1
	switch x := value.NPitEntries; {
	case x <= 0xff:
		buf[pos] = 1
		buf[pos+1] = byte(x)
		pos += 2
	case x <= 0xffff:
		buf[pos] = 2
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 4
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 8
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
	buf[pos] = byte(134)
	pos += 1
	switch x := value.NMeasurementsEntries; {
	case x <= 0xff:
		buf[pos] = 1
		buf[pos+1] = byte(x)
		pos += 2
	case x <= 0xffff:
		buf[pos] = 2
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 4
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 8
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
	buf[pos] = byte(135)
	pos += 1
	switch x := value.NCsEntries; {
	case x <= 0xff:
		buf[pos] = 1
		buf[pos+1] = byte(x)
		pos += 2
	case x <= 0xffff:
		buf[pos] = 2
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 4
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 8
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
	buf[pos] = byte(144)
	pos += 1
	switch x := value.NInInterests; {
	case x <= 0xff:
		buf[pos] = 1
		buf[pos+1] = byte(x)
		pos += 2
	case x <= 0xffff:
		buf[pos] = 2
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 4
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 8
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
	buf[pos] = byte(145)
	pos += 1
	switch x := value.NInData; {
	case x <= 0xff:
		buf[pos] = 1
		buf[pos+1] = byte(x)
		pos += 2
	case x <= 0xffff:
		buf[pos] = 2
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 4
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 8
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
	buf[pos] = byte(151)
	pos += 1
	switch x := value.NInNacks; {
	case x <= 0xff:
		buf[pos] = 1
		buf[pos+1] = byte(x)
		pos += 2
	case x <= 0xffff:
		buf[pos] = 2
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 4
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 8
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
	buf[pos] = byte(146)
	pos += 1
	switch x := value.NOutInterests; {
	case x <= 0xff:
		buf[pos] = 1
		buf[pos+1] = byte(x)
		pos += 2
	case x <= 0xffff:
		buf[pos] = 2
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 4
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 8
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
	buf[pos] = byte(147)
	pos += 1
	switch x := value.NOutData; {
	case x <= 0xff:
		buf[pos] = 1
		buf[pos+1] = byte(x)
		pos += 2
	case x <= 0xffff:
		buf[pos] = 2
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 4
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 8
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
	buf[pos] = byte(152)
	pos += 1
	switch x := value.NOutNacks; {
	case x <= 0xff:
		buf[pos] = 1
		buf[pos+1] = byte(x)
		pos += 2
	case x <= 0xffff:
		buf[pos] = 2
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 4
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 8
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
	buf[pos] = byte(153)
	pos += 1
	switch x := value.NSatisfiedInterests; {
	case x <= 0xff:
		buf[pos] = 1
		buf[pos+1] = byte(x)
		pos += 2
	case x <= 0xffff:
		buf[pos] = 2
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 4
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 8
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
	buf[pos] = byte(154)
	pos += 1
	switch x := value.NUnsatisfiedInterests; {
	case x <= 0xff:
		buf[pos] = 1
		buf[pos+1] = byte(x)
		pos += 2
	case x <= 0xffff:
		buf[pos] = 2
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 4
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 8
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
	if value.NFragmentationError != nil {
		buf[pos] = byte(200)
		pos += 1
		switch x := *value.NFragmentationError; {
		case x <= 0xff:
			buf[pos] = 1
			buf[pos+1] = byte(x)
			pos += 2
		case x <= 0xffff:
			buf[pos] = 2
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 4
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 8
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
	}
	if value.NOutOverMtu != nil {
		buf[pos] = byte(201)
		pos += 1
		switch x := *value.NOutOverMtu; {
		case x <= 0xff:
			buf[pos] = 1
			buf[pos+1] = byte(x)
			pos += 2
		case x <= 0xffff:
			buf[pos] = 2
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 4
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 8
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
	}
	if value.NInLpInvalid != nil {
		buf[pos] = byte(202)
		pos += 1
		switch x := *value.NInLpInvalid; {
		case x <= 0xff:
			buf[pos] = 1
			buf[pos+1] = byte(x)
			pos += 2
		case x <= 0xffff:
			buf[pos] = 2
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 4
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 8
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
	}
	if value.NReassemblyTimeouts != nil {
		buf[pos] = byte(203)
		pos += 1
		switch x := *value.NReassemblyTimeouts; {
		case x <= 0xff:
			buf[pos] = 1
			buf[pos+1] = byte(x)
			pos += 2
		case x <= 0xffff:
			buf[pos] = 2
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 4
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 8
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
	}
	if value.NInNetInvalid != nil {
		buf[pos] = byte(204)
		pos += 1
		switch x := *value.NInNetInvalid; {
		case x <= 0xff:
			buf[pos] = 1
			buf[pos+1] = byte(x)
			pos += 2
		case x <= 0xffff:
			buf[pos] = 2
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 4
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 8
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
	}
	if value.NAcknowledged != nil {
		buf[pos] = byte(205)
		pos += 1
		switch x := *value.NAcknowledged; {
		case x <= 0xff:
			buf[pos] = 1
			buf[pos+1] = byte(x)
			pos += 2
		case x <= 0xffff:
			buf[pos] = 2
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 4
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 8
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
	}
	if value.NRetransmitted != nil {
		buf[pos] = byte(206)
		pos += 1
		switch x := *value.NRetransmitted; {
		case x <= 0xff:
			buf[pos] = 1
			buf[pos+1] = byte(x)
			pos += 2
		case x <= 0xffff:
			buf[pos] = 2
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 4
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 8
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
	}
	if value.NRetxExhausted != nil {
		buf[pos] = byte(207)
		pos += 1
		switch x := *value.NRetxExhausted; {
		case x <= 0xff:
			buf[pos] = 1
			buf[pos+1] = byte(x)
			pos += 2
		case x <= 0xffff:
			buf[pos] = 2
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 4
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 8
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
	}
	if value.NConngestionMarked != nil {
		buf[pos] = byte(208)
		pos += 1
		switch x := *value.NConngestionMarked; {
		case x <= 0xff:
			buf[pos] = 1
			buf[pos+1] = byte(x)
			pos += 2
		case x <= 0xffff:
			buf[pos] = 2
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 4
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 8
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
	}
}

func (encoder *GeneralStatusEncoder) Encode(value *GeneralStatus) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *GeneralStatusParsingContext) Parse(reader enc.ParseReader, ignoreCritical bool) (*GeneralStatus, error) {
	if reader == nil {
		return nil, enc.ErrBufferOverflow
	}

	var handled_NfdVersion bool = false
	var handled_StartTimestamp bool = false
	var handled_CurrentTimestamp bool = false
	var handled_NNameTreeEntries bool = false
	var handled_NFibEntries bool = false
	var handled_NPitEntries bool = false
	var handled_NMeasurementsEntries bool = false
	var handled_NCsEntries bool = false
	var handled_NInInterests bool = false
	var handled_NInData bool = false
	var handled_NInNacks bool = false
	var handled_NOutInterests bool = false
	var handled_NOutData bool = false
	var handled_NOutNacks bool = false
	var handled_NSatisfiedInterests bool = false
	var handled_NUnsatisfiedInterests bool = false
	var handled_NFragmentationError bool = false
	var handled_NOutOverMtu bool = false
	var handled_NInLpInvalid bool = false
	var handled_NReassemblyTimeouts bool = false
	var handled_NInNetInvalid bool = false
	var handled_NAcknowledged bool = false
	var handled_NRetransmitted bool = false
	var handled_NRetxExhausted bool = false
	var handled_NConngestionMarked bool = false

	progress := -1
	_ = progress

	value := &GeneralStatus{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 128:
				if true {
					handled = true
					handled_NfdVersion = true
					{
						var builder strings.Builder
						_, err = io.CopyN(&builder, reader, int64(l))
						if err == nil {
							value.NfdVersion = builder.String()
						}
					}
				}
			case 129:
				if true {
					handled = true
					handled_StartTimestamp = true
					value.StartTimestamp = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.StartTimestamp = uint64(value.StartTimestamp<<8) | uint64(x)
						}
					}
				}
			case 130:
				if true {
					handled = true
					handled_CurrentTimestamp = true
					value.CurrentTimestamp = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.CurrentTimestamp = uint64(value.CurrentTimestamp<<8) | uint64(x)
						}
					}
				}
			case 131:
				if true {
					handled = true
					handled_NNameTreeEntries = true
					value.NNameTreeEntries = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.NNameTreeEntries = uint64(value.NNameTreeEntries<<8) | uint64(x)
						}
					}
				}
			case 132:
				if true {
					handled = true
					handled_NFibEntries = true
					value.NFibEntries = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.NFibEntries = uint64(value.NFibEntries<<8) | uint64(x)
						}
					}
				}
			case 133:
				if true {
					handled = true
					handled_NPitEntries = true
					value.NPitEntries = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.NPitEntries = uint64(value.NPitEntries<<8) | uint64(x)
						}
					}
				}
			case 134:
				if true {
					handled = true
					handled_NMeasurementsEntries = true
					value.NMeasurementsEntries = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.NMeasurementsEntries = uint64(value.NMeasurementsEntries<<8) | uint64(x)
						}
					}
				}
			case 135:
				if true {
					handled = true
					handled_NCsEntries = true
					value.NCsEntries = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.NCsEntries = uint64(value.NCsEntries<<8) | uint64(x)
						}
					}
				}
			case 144:
				if true {
					handled = true
					handled_NInInterests = true
					value.NInInterests = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.NInInterests = uint64(value.NInInterests<<8) | uint64(x)
						}
					}
				}
			case 145:
				if true {
					handled = true
					handled_NInData = true
					value.NInData = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.NInData = uint64(value.NInData<<8) | uint64(x)
						}
					}
				}
			case 151:
				if true {
					handled = true
					handled_NInNacks = true
					value.NInNacks = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.NInNacks = uint64(value.NInNacks<<8) | uint64(x)
						}
					}
				}
			case 146:
				if true {
					handled = true
					handled_NOutInterests = true
					value.NOutInterests = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.NOutInterests = uint64(value.NOutInterests<<8) | uint64(x)
						}
					}
				}
			case 147:
				if true {
					handled = true
					handled_NOutData = true
					value.NOutData = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.NOutData = uint64(value.NOutData<<8) | uint64(x)
						}
					}
				}
			case 152:
				if true {
					handled = true
					handled_NOutNacks = true
					value.NOutNacks = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.NOutNacks = uint64(value.NOutNacks<<8) | uint64(x)
						}
					}
				}
			case 153:
				if true {
					handled = true
					handled_NSatisfiedInterests = true
					value.NSatisfiedInterests = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.NSatisfiedInterests = uint64(value.NSatisfiedInterests<<8) | uint64(x)
						}
					}
				}
			case 154:
				if true {
					handled = true
					handled_NUnsatisfiedInterests = true
					value.NUnsatisfiedInterests = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.NUnsatisfiedInterests = uint64(value.NUnsatisfiedInterests<<8) | uint64(x)
						}
					}
				}
			case 200:
				if true {
					handled = true
					handled_NFragmentationError = true
					{
						tempVal := uint64(0)
						tempVal = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								tempVal = uint64(tempVal<<8) | uint64(x)
							}
						}
						value.NFragmentationError = &tempVal
					}
				}
			case 201:
				if true {
					handled = true
					handled_NOutOverMtu = true
					{
						tempVal := uint64(0)
						tempVal = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								tempVal = uint64(tempVal<<8) | uint64(x)
							}
						}
						value.NOutOverMtu = &tempVal
					}
				}
			case 202:
				if true {
					handled = true
					handled_NInLpInvalid = true
					{
						tempVal := uint64(0)
						tempVal = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								tempVal = uint64(tempVal<<8) | uint64(x)
							}
						}
						value.NInLpInvalid = &tempVal
					}
				}
			case 203:
				if true {
					handled = true
					handled_NReassemblyTimeouts = true
					{
						tempVal := uint64(0)
						tempVal = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								tempVal = uint64(tempVal<<8) | uint64(x)
							}
						}
						value.NReassemblyTimeouts = &tempVal
					}
				}
			case 204:
				if true {
					handled = true
					handled_NInNetInvalid = true
					{
						tempVal := uint64(0)
						tempVal = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								tempVal = uint64(tempVal<<8) | uint64(x)
							}
						}
						value.NInNetInvalid = &tempVal
					}
				}
			case 205:
				if true {
					handled = true
					handled_NAcknowledged = true
					{
						tempVal := uint64(0)
						tempVal = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								tempVal = uint64(tempVal<<8) | uint64(x)
							}
						}
						value.NAcknowledged = &tempVal
					}
				}
			case 206:
				if true {
					handled = true
					handled_NRetransmitted = true
					{
						tempVal := uint64(0)
						tempVal = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								tempVal = uint64(tempVal<<8) | uint64(x)
							}
						}
						value.NRetransmitted = &tempVal
					}
				}
			case 207:
				if true {
					handled = true
					handled_NRetxExhausted = true
					{
						tempVal := uint64(0)
						tempVal = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								tempVal = uint64(tempVal<<8) | uint64(x)
							}
						}
						value.NRetxExhausted = &tempVal
					}
				}
			case 208:
				if true {
					handled = true
					handled_NConngestionMarked = true
					{
						tempVal := uint64(0)
						tempVal = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								tempVal = uint64(tempVal<<8) | uint64(x)
							}
						}
						value.NConngestionMarked = &tempVal
					}
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_NfdVersion && err == nil {
		err = enc.ErrSkipRequired{Name: "NfdVersion", TypeNum: 128}
	}
	if !handled_StartTimestamp && err == nil {
		err = enc.ErrSkipRequired{Name: "StartTimestamp", TypeNum: 129}
	}
	if !handled_CurrentTimestamp && err == nil {
		err = enc.ErrSkipRequired{Name: "CurrentTimestamp", TypeNum: 130}
	}
	if !handled_NNameTreeEntries && err == nil {
		err = enc.ErrSkipRequired{Name: "NNameTreeEntries", TypeNum: 131}
	}
	if !handled_NFibEntries && err == nil {
		err = enc.ErrSkipRequired{Name: "NFibEntries", TypeNum: 132}
	}
	if !handled_NPitEntries && err == nil {
		err = enc.ErrSkipRequired{Name: "NPitEntries", TypeNum: 133}
	}
	if !handled_NMeasurementsEntries && err == nil {
		err = enc.ErrSkipRequired{Name: "NMeasurementsEntries", TypeNum: 134}
	}
	if !handled_NCsEntries && err == nil {
		err = enc.ErrSkipRequired{Name: "NCsEntries", TypeNum: 135}
	}
	if !handled_NInInterests && err == nil {
		err = enc.ErrSkipRequired{Name: "NInInterests", TypeNum: 144}
	}
	if !handled_NInData && err == nil {
		err = enc.ErrSkipRequired{Name: "NInData", TypeNum: 145}
	}
	if !handled_NInNacks && err == nil {
		err = enc.ErrSkipRequired{Name: "NInNacks", TypeNum: 151}
	}
	if !handled_NOutInterests && err == nil {
		err = enc.ErrSkipRequired{Name: "NOutInterests", TypeNum: 146}
	}
	if !handled_NOutData && err == nil {
		err = enc.ErrSkipRequired{Name: "NOutData", TypeNum: 147}
	}
	if !handled_NOutNacks && err == nil {
		err = enc.ErrSkipRequired{Name: "NOutNacks", TypeNum: 152}
	}
	if !handled_NSatisfiedInterests && err == nil {
		err = enc.ErrSkipRequired{Name: "NSatisfiedInterests", TypeNum: 153}
	}
	if !handled_NUnsatisfiedInterests && err == nil {
		err = enc.ErrSkipRequired{Name: "NUnsatisfiedInterests", TypeNum: 154}
	}
	if !handled_NFragmentationError && err == nil {
		value.NFragmentationError = nil
	}
	if !handled_NOutOverMtu && err == nil {
		value.NOutOverMtu = nil
	}
	if !handled_NInLpInvalid && err == nil {
		value.NInLpInvalid = nil
	}
	if !handled_NReassemblyTimeouts && err == nil {
		value.NReassemblyTimeouts = nil
	}
	if !handled_NInNetInvalid && err == nil {
		value.NInNetInvalid = nil
	}
	if !handled_NAcknowledged && err == nil {
		value.NAcknowledged = nil
	}
	if !handled_NRetransmitted && err == nil {
		value.NRetransmitted = nil
	}
	if !handled_NRetxExhausted && err == nil {
		value.NRetxExhausted = nil
	}
	if !handled_NConngestionMarked && err == nil {
		value.NConngestionMarked = nil
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *GeneralStatus) Encode() enc.Wire {
	encoder := GeneralStatusEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *GeneralStatus) Bytes() []byte {
	return value.Encode().Join()
}

func ParseGeneralStatus(reader enc.ParseReader, ignoreCritical bool) (*GeneralStatus, error) {
	context := GeneralStatusParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type FaceStatusEncoder struct {
	length uint
}

type FaceStatusParsingContext struct {
}

func (encoder *FaceStatusEncoder) Init(value *FaceStatus) {

	l := uint(0)
	l += 1
	switch x := value.FaceId; {
	case x <= 0xff:
		l += 2
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	l += 1
	switch x := len(value.Uri); {
	case x <= 0xfc:
		l += 1
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	l += uint(len(value.Uri))
	l += 1
	switch x := len(value.LocalUri); {
	case x <= 0xfc:
		l += 1
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	l += uint(len(value.LocalUri))
	if value.ExpirationPeriod != nil {
		l += 1
		switch x := *value.ExpirationPeriod; {
		case x <= 0xff:
			l += 2
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
	}
	l += 1
	switch x := value.FaceScope; {
	case x <= 0xff:
		l += 2
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	l += 1
	switch x := value.FacePersistency; {
	case x <= 0xff:
		l += 2
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	l += 1
	switch x := value.LinkType; {
	case x <= 0xff:
		l += 2
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	if value.BaseCongestionMarkInterval != nil {
		l += 1
		switch x := *value.BaseCongestionMarkInterval; {
		case x <= 0xff:
			l += 2
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
	}
	if value.DefaultCongestionThreshold != nil {
		l += 1
		switch x := *value.DefaultCongestionThreshold; {
		case x <= 0xff:
			l += 2
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
	}
	if value.Mtu != nil {
		l += 1
		switch x := *value.Mtu; {
		case x <= 0xff:
			l += 2
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
	}
	l += 1
	switch x := value.NInInterests; {
	case x <= 0xff:
		l += 2
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	l += 1
	switch x := value.NInData; {
	case x <= 0xff:
		l += 2
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	l += 1
	switch x := value.NInNacks; {
	case x <= 0xff:
		l += 2
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	l += 1
	switch x := value.NOutInterests; {
	case x <= 0xff:
		l += 2
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	l += 1
	switch x := value.NOutData; {
	case x <= 0xff:
		l += 2
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	l += 1
	switch x := value.NOutNacks; {
	case x <= 0xff:
		l += 2
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	l += 1
	switch x := value.NInBytes; {
	case x <= 0xff:
		l += 2
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	l += 1
	switch x := value.NOutBytes; {
	case x <= 0xff:
		l += 2
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	l += 1
	switch x := value.Flags; {
	case x <= 0xff:
		l += 2
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	encoder.length = l

}

func (context *FaceStatusParsingContext) Init() {

}

func (encoder *FaceStatusEncoder) EncodeInto(value *FaceStatus, buf []byte) {

	pos := uint(0)

	buf[pos] = byte(105)
	pos += 1
	switch x := value.FaceId; {
	case x <= 0xff:
		buf[pos] = 1
		buf[pos+1] = byte(x)
		pos += 2
	case x <= 0xffff:
		buf[pos] = 2
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 4
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 8
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
	buf[pos] = byte(114)
	pos += 1
	switch x := len(value.Uri); {
	case x <= 0xfc:
		buf[pos] = byte(x)
		pos += 1
	case x <= 0xffff:
		buf[pos] = 0xfd
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 0xfe
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 0xff
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
	copy(buf[pos:], value.Uri)
	pos += uint(len(value.Uri))
	buf[pos] = byte(129)
	pos += 1
	switch x := len(value.LocalUri); {
	case x <= 0xfc:
		buf[pos] = byte(x)
		pos += 1
	case x <= 0xffff:
		buf[pos] = 0xfd
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 0xfe
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 0xff
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
	copy(buf[pos:], value.LocalUri)
	pos += uint(len(value.LocalUri))
	if value.ExpirationPeriod != nil {
		buf[pos] = byte(109)
		pos += 1
		switch x := *value.ExpirationPeriod; {
		case x <= 0xff:
			buf[pos] = 1
			buf[pos+1] = byte(x)
			pos += 2
		case x <= 0xffff:
			buf[pos] = 2
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 4
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 8
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
	}
	buf[pos] = byte(132)
	pos += 1
	switch x := value.FaceScope; {
	case x <= 0xff:
		buf[pos] = 1
		buf[pos+1] = byte(x)
		pos += 2
	case x <= 0xffff:
		buf[pos] = 2
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 4
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 8
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
	buf[pos] = byte(133)
	pos += 1
	switch x := value.FacePersistency; {
	case x <= 0xff:
		buf[pos] = 1
		buf[pos+1] = byte(x)
		pos += 2
	case x <= 0xffff:
		buf[pos] = 2
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 4
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 8
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
	buf[pos] = byte(134)
	pos += 1
	switch x := value.LinkType; {
	case x <= 0xff:
		buf[pos] = 1
		buf[pos+1] = byte(x)
		pos += 2
	case x <= 0xffff:
		buf[pos] = 2
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 4
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 8
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
	if value.BaseCongestionMarkInterval != nil {
		buf[pos] = byte(135)
		pos += 1
		switch x := *value.BaseCongestionMarkInterval; {
		case x <= 0xff:
			buf[pos] = 1
			buf[pos+1] = byte(x)
			pos += 2
		case x <= 0xffff:
			buf[pos] = 2
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 4
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 8
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
	}
	if value.DefaultCongestionThreshold != nil {
		buf[pos] = byte(136)
		pos += 1
		switch x := *value.DefaultCongestionThreshold; {
		case x <= 0xff:
			buf[pos] = 1
			buf[pos+1] = byte(x)
			pos += 2
		case x <= 0xffff:
			buf[pos] = 2
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 4
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 8
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
	}
	if value.Mtu != nil {
		buf[pos] = byte(137)
		pos += 1
		switch x := *value.Mtu; {
		case x <= 0xff:
			buf[pos] = 1
			buf[pos+1] = byte(x)
			pos += 2
		case x <= 0xffff:
			buf[pos] = 2
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 4
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 8
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
	}
	buf[pos] = byte(144)
	pos += 1
	switch x := value.NInInterests; {
	case x <= 0xff:
		buf[pos] = 1
		buf[pos+1] = byte(x)
		pos += 2
	case x <= 0xffff:
		buf[pos] = 2
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 4
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 8
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
	buf[pos] = byte(145)
	pos += 1
	switch x := value.NInData; {
	case x <= 0xff:
		buf[pos] = 1
		buf[pos+1] = byte(x)
		pos += 2
	case x <= 0xffff:
		buf[pos] = 2
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 4
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 8
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
	buf[pos] = byte(151)
	pos += 1
	switch x := value.NInNacks; {
	case x <= 0xff:
		buf[pos] = 1
		buf[pos+1] = byte(x)
		pos += 2
	case x <= 0xffff:
		buf[pos] = 2
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 4
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 8
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
	buf[pos] = byte(146)
	pos += 1
	switch x := value.NOutInterests; {
	case x <= 0xff:
		buf[pos] = 1
		buf[pos+1] = byte(x)
		pos += 2
	case x <= 0xffff:
		buf[pos] = 2
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 4
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 8
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
	buf[pos] = byte(147)
	pos += 1
	switch x := value.NOutData; {
	case x <= 0xff:
		buf[pos] = 1
		buf[pos+1] = byte(x)
		pos += 2
	case x <= 0xffff:
		buf[pos] = 2
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 4
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 8
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
	buf[pos] = byte(152)
	pos += 1
	switch x := value.NOutNacks; {
	case x <= 0xff:
		buf[pos] = 1
		buf[pos+1] = byte(x)
		pos += 2
	case x <= 0xffff:
		buf[pos] = 2
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 4
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 8
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
	buf[pos] = byte(148)
	pos += 1
	switch x := value.NInBytes; {
	case x <= 0xff:
		buf[pos] = 1
		buf[pos+1] = byte(x)
		pos += 2
	case x <= 0xffff:
		buf[pos] = 2
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 4
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 8
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
	buf[pos] = byte(149)
	pos += 1
	switch x := value.NOutBytes; {
	case x <= 0xff:
		buf[pos] = 1
		buf[pos+1] = byte(x)
		pos += 2
	case x <= 0xffff:
		buf[pos] = 2
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 4
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 8
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
	buf[pos] = byte(108)
	pos += 1
	switch x := value.Flags; {
	case x <= 0xff:
		buf[pos] = 1
		buf[pos+1] = byte(x)
		pos += 2
	case x <= 0xffff:
		buf[pos] = 2
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 4
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 8
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
}

func (encoder *FaceStatusEncoder) Encode(value *FaceStatus) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *FaceStatusParsingContext) Parse(reader enc.ParseReader, ignoreCritical bool) (*FaceStatus, error) {
	if reader == nil {
		return nil, enc.ErrBufferOverflow
	}

	var handled_FaceId bool = false
	var handled_Uri bool = false
	var handled_LocalUri bool = false
	var handled_ExpirationPeriod bool = false
	var handled_FaceScope bool = false
	var handled_FacePersistency bool = false
	var handled_LinkType bool = false
	var handled_BaseCongestionMarkInterval bool = false
	var handled_DefaultCongestionThreshold bool = false
	var handled_Mtu bool = false
	var handled_NInInterests bool = false
	var handled_NInData bool = false
	var handled_NInNacks bool = false
	var handled_NOutInterests bool = false
	var handled_NOutData bool = false
	var handled_NOutNacks bool = false
	var handled_NInBytes bool = false
	var handled_NOutBytes bool = false
	var handled_Flags bool = false

	progress := -1
	_ = progress

	value := &FaceStatus{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 105:
				if true {
					handled = true
					handled_FaceId = true
					value.FaceId = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.FaceId = uint64(value.FaceId<<8) | uint64(x)
						}
					}
				}
			case 114:
				if true {
					handled = true
					handled_Uri = true
					{
						var builder strings.Builder
						_, err = io.CopyN(&builder, reader, int64(l))
						if err == nil {
							value.Uri = builder.String()
						}
					}
				}
			case 129:
				if true {
					handled = true
					handled_LocalUri = true
					{
						var builder strings.Builder
						_, err = io.CopyN(&builder, reader, int64(l))
						if err == nil {
							value.LocalUri = builder.String()
						}
					}
				}
			case 109:
				if true {
					handled = true
					handled_ExpirationPeriod = true
					{
						tempVal := uint64(0)
						tempVal = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								tempVal = uint64(tempVal<<8) | uint64(x)
							}
						}
						value.ExpirationPeriod = &tempVal
					}
				}
			case 132:
				if true {
					handled = true
					handled_FaceScope = true
					value.FaceScope = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.FaceScope = uint64(value.FaceScope<<8) | uint64(x)
						}
					}
				}
			case 133:
				if true {
					handled = true
					handled_FacePersistency = true
					value.FacePersistency = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.FacePersistency = uint64(value.FacePersistency<<8) | uint64(x)
						}
					}
				}
			case 134:
				if true {
					handled = true
					handled_LinkType = true
					value.LinkType = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.LinkType = uint64(value.LinkType<<8) | uint64(x)
						}
					}
				}
			case 135:
				if true {
					handled = true
					handled_BaseCongestionMarkInterval = true
					{
						tempVal := uint64(0)
						tempVal = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								tempVal = uint64(tempVal<<8) | uint64(x)
							}
						}
						value.BaseCongestionMarkInterval = &tempVal
					}
				}
			case 136:
				if true {
					handled = true
					handled_DefaultCongestionThreshold = true
					{
						tempVal := uint64(0)
						tempVal = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								tempVal = uint64(tempVal<<8) | uint64(x)
							}
						}
						value.DefaultCongestionThreshold = &tempVal
					}
				}
			case 137:
				if true {
					handled = true
					handled_Mtu = true
					{
						tempVal := uint64(0)
						tempVal = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								tempVal = uint64(tempVal<<8) | uint64(x)
							}
						}
						value.Mtu = &tempVal
					}
				}
			case 144:
				if true {
					handled = true
					handled_NInInterests = true
					value.NInInterests = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.NInInterests = uint64(value.NInInterests<<8) | uint64(x)
						}
					}
				}
			case 145:
				if true {
					handled = true
					handled_NInData = true
					value.NInData = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.NInData = uint64(value.NInData<<8) | uint64(x)
						}
					}
				}
			case 151:
				if true {
					handled = true
					handled_NInNacks = true
					value.NInNacks = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.NInNacks = uint64(value.NInNacks<<8) | uint64(x)
						}
					}
				}
			case 146:
				if true {
					handled = true
					handled_NOutInterests = true
					value.NOutInterests = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.NOutInterests = uint64(value.NOutInterests<<8) | uint64(x)
						}
					}
				}
			case 147:
				if true {
					handled = true
					handled_NOutData = true
					value.NOutData = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.NOutData = uint64(value.NOutData<<8) | uint64(x)
						}
					}
				}
			case 152:
				if true {
					handled = true
					handled_NOutNacks = true
					value.NOutNacks = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.NOutNacks = uint64(value.NOutNacks<<8) | uint64(x)
						}
					}
				}
			case 148:
				if true {
					handled = true
					handled_NInBytes = true
					value.NInBytes = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.NInBytes = uint64(value.NInBytes<<8) | uint64(x)
						}
					}
				}
			case 149:
				if true {
					handled = true
					handled_NOutBytes = true
					value.NOutBytes = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.NOutBytes = uint64(value.NOutBytes<<8) | uint64(x)
						}
					}
				}
			case 108:
				if true {
					handled = true
					handled_Flags = true
					value.Flags = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.Flags = uint64(value.Flags<<8) | uint64(x)
						}
					}
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_FaceId && err == nil {
		err = enc.ErrSkipRequired{Name: "FaceId", TypeNum: 105}
	}
	if !handled_Uri && err == nil {
		err = enc.ErrSkipRequired{Name: "Uri", TypeNum: 114}
	}
	if !handled_LocalUri && err == nil {
		err = enc.ErrSkipRequired{Name: "LocalUri", TypeNum: 129}
	}
	if !handled_ExpirationPeriod && err == nil {
		value.ExpirationPeriod = nil
	}
	if !handled_FaceScope && err == nil {
		err = enc.ErrSkipRequired{Name: "FaceScope", TypeNum: 132}
	}
	if !handled_FacePersistency && err == nil {
		err = enc.ErrSkipRequired{Name: "FacePersistency", TypeNum: 133}
	}
	if !handled_LinkType && err == nil {
		err = enc.ErrSkipRequired{Name: "LinkType", TypeNum: 134}
	}
	if !handled_BaseCongestionMarkInterval && err == nil {
		value.BaseCongestionMarkInterval = nil
	}
	if !handled_DefaultCongestionThreshold && err == nil {
		value.DefaultCongestionThreshold = nil
	}
	if !handled_Mtu && err == nil {
		value.Mtu = nil
	}
	if !handled_NInInterests && err == nil {
		err = enc.ErrSkipRequired{Name: "NInInterests", TypeNum: 144}
	}
	if !handled_NInData && err == nil {
		err = enc.ErrSkipRequired{Name: "NInData", TypeNum: 145}
	}
	if !handled_NInNacks && err == nil {
		err = enc.ErrSkipRequired{Name: "NInNacks", TypeNum: 151}
	}
	if !handled_NOutInterests && err == nil {
		err = enc.ErrSkipRequired{Name: "NOutInterests", TypeNum: 146}
	}
	if !handled_NOutData && err == nil {
		err = enc.ErrSkipRequired{Name: "NOutData", TypeNum: 147}
	}
	if !handled_NOutNacks && err == nil {
		err = enc.ErrSkipRequired{Name: "NOutNacks", TypeNum: 152}
	}
	if !handled_NInBytes && err == nil {
		err = enc.ErrSkipRequired{Name: "NInBytes", TypeNum: 148}
	}
	if !handled_NOutBytes && err == nil {
		err = enc.ErrSkipRequired{Name: "NOutBytes", TypeNum: 149}
	}
	if !handled_Flags && err == nil {
		err = enc.ErrSkipRequired{Name: "Flags", TypeNum: 108}
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *FaceStatus) Encode() enc.Wire {
	encoder := FaceStatusEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *FaceStatus) Bytes() []byte {
	return value.Encode().Join()
}

func ParseFaceStatus(reader enc.ParseReader, ignoreCritical bool) (*FaceStatus, error) {
	context := FaceStatusParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type FaceStatusMsgEncoder struct {
	length uint

	Vals_subencoder []struct {
		Vals_encoder FaceStatusEncoder
	}
}

type FaceStatusMsgParsingContext struct {
	Vals_context FaceStatusParsingContext
}

func (encoder *FaceStatusMsgEncoder) Init(value *FaceStatusMsg) {
	{
		Vals_l := len(value.Vals)
		encoder.Vals_subencoder = make([]struct {
			Vals_encoder FaceStatusEncoder
		}, Vals_l)
		for i := 0; i < Vals_l; i++ {
			pseudoEncoder := &encoder.Vals_subencoder[i]
			pseudoValue := struct {
				Vals *FaceStatus
			}{
				Vals: value.Vals[i],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Vals != nil {
					encoder.Vals_encoder.Init(value.Vals)
				}
				_ = encoder
				_ = value
			}
		}
	}

	l := uint(0)
	if value.Vals != nil {
		for seq_i, seq_v := range value.Vals {
			pseudoEncoder := &encoder.Vals_subencoder[seq_i]
			pseudoValue := struct {
				Vals *FaceStatus
			}{
				Vals: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Vals != nil {
					l += 1
					switch x := encoder.Vals_encoder.length; {
					case x <= 0xfc:
						l += 1
					case x <= 0xffff:
						l += 3
					case x <= 0xffffffff:
						l += 5
					default:
						l += 9
					}
					l += encoder.Vals_encoder.length
				}
				_ = encoder
				_ = value
			}
		}
	}
	encoder.length = l

}

func (context *FaceStatusMsgParsingContext) Init() {
	context.Vals_context.Init()
}

func (encoder *FaceStatusMsgEncoder) EncodeInto(value *FaceStatusMsg, buf []byte) {

	pos := uint(0)

	if value.Vals != nil {
		for seq_i, seq_v := range value.Vals {
			pseudoEncoder := &encoder.Vals_subencoder[seq_i]
			pseudoValue := struct {
				Vals *FaceStatus
			}{
				Vals: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Vals != nil {
					buf[pos] = byte(128)
					pos += 1
					switch x := encoder.Vals_encoder.length; {
					case x <= 0xfc:
						buf[pos] = byte(x)
						pos += 1
					case x <= 0xffff:
						buf[pos] = 0xfd
						binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
						pos += 3
					case x <= 0xffffffff:
						buf[pos] = 0xfe
						binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
						pos += 5
					default:
						buf[pos] = 0xff
						binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
						pos += 9
					}
					if encoder.Vals_encoder.length > 0 {
						encoder.Vals_encoder.EncodeInto(value.Vals, buf[pos:])
						pos += encoder.Vals_encoder.length
					}
				}
				_ = encoder
				_ = value
			}
		}
	}
}

func (encoder *FaceStatusMsgEncoder) Encode(value *FaceStatusMsg) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *FaceStatusMsgParsingContext) Parse(reader enc.ParseReader, ignoreCritical bool) (*FaceStatusMsg, error) {
	if reader == nil {
		return nil, enc.ErrBufferOverflow
	}

	var handled_Vals bool = false

	progress := -1
	_ = progress

	value := &FaceStatusMsg{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 128:
				if true {
					handled = true
					handled_Vals = true
					if value.Vals == nil {
						value.Vals = make([]*FaceStatus, 0)
					}
					{
						pseudoValue := struct {
							Vals *FaceStatus
						}{}
						{
							value := &pseudoValue
							value.Vals, err = context.Vals_context.Parse(reader.Delegate(int(l)), ignoreCritical)
							_ = value
						}
						value.Vals = append(value.Vals, pseudoValue.Vals)
					}
					progress--
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Vals && err == nil {
		// sequence - skip
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *FaceStatusMsg) Encode() enc.Wire {
	encoder := FaceStatusMsgEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *FaceStatusMsg) Bytes() []byte {
	return value.Encode().Join()
}

func ParseFaceStatusMsg(reader enc.ParseReader, ignoreCritical bool) (*FaceStatusMsg, error) {
	context := FaceStatusMsgParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type FaceQueryFilterValueEncoder struct {
	length uint
}

type FaceQueryFilterValueParsingContext struct {
}

func (encoder *FaceQueryFilterValueEncoder) Init(value *FaceQueryFilterValue) {

	l := uint(0)
	if value.FaceId != nil {
		l += 1
		switch x := *value.FaceId; {
		case x <= 0xff:
			l += 2
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
	}
	if value.UriScheme != nil {
		l += 1
		switch x := len(*value.UriScheme); {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		l += uint(len(*value.UriScheme))
	}
	if value.Uri != nil {
		l += 1
		switch x := len(*value.Uri); {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		l += uint(len(*value.Uri))
	}
	if value.LocalUri != nil {
		l += 1
		switch x := len(*value.LocalUri); {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		l += uint(len(*value.LocalUri))
	}
	if value.FaceScope != nil {
		l += 1
		switch x := *value.FaceScope; {
		case x <= 0xff:
			l += 2
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
	}
	if value.FacePersistency != nil {
		l += 1
		switch x := *value.FacePersistency; {
		case x <= 0xff:
			l += 2
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
	}
	if value.LinkType != nil {
		l += 1
		switch x := *value.LinkType; {
		case x <= 0xff:
			l += 2
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
	}
	encoder.length = l

}

func (context *FaceQueryFilterValueParsingContext) Init() {

}

func (encoder *FaceQueryFilterValueEncoder) EncodeInto(value *FaceQueryFilterValue, buf []byte) {

	pos := uint(0)

	if value.FaceId != nil {
		buf[pos] = byte(105)
		pos += 1
		switch x := *value.FaceId; {
		case x <= 0xff:
			buf[pos] = 1
			buf[pos+1] = byte(x)
			pos += 2
		case x <= 0xffff:
			buf[pos] = 2
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 4
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 8
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
	}
	if value.UriScheme != nil {
		buf[pos] = byte(131)
		pos += 1
		switch x := len(*value.UriScheme); {
		case x <= 0xfc:
			buf[pos] = byte(x)
			pos += 1
		case x <= 0xffff:
			buf[pos] = 0xfd
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 0xfe
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 0xff
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
		copy(buf[pos:], *value.UriScheme)
		pos += uint(len(*value.UriScheme))
	}
	if value.Uri != nil {
		buf[pos] = byte(114)
		pos += 1
		switch x := len(*value.Uri); {
		case x <= 0xfc:
			buf[pos] = byte(x)
			pos += 1
		case x <= 0xffff:
			buf[pos] = 0xfd
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 0xfe
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 0xff
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
		copy(buf[pos:], *value.Uri)
		pos += uint(len(*value.Uri))
	}
	if value.LocalUri != nil {
		buf[pos] = byte(129)
		pos += 1
		switch x := len(*value.LocalUri); {
		case x <= 0xfc:
			buf[pos] = byte(x)
			pos += 1
		case x <= 0xffff:
			buf[pos] = 0xfd
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 0xfe
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 0xff
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
		copy(buf[pos:], *value.LocalUri)
		pos += uint(len(*value.LocalUri))
	}
	if value.FaceScope != nil {
		buf[pos] = byte(132)
		pos += 1
		switch x := *value.FaceScope; {
		case x <= 0xff:
			buf[pos] = 1
			buf[pos+1] = byte(x)
			pos += 2
		case x <= 0xffff:
			buf[pos] = 2
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 4
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 8
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
	}
	if value.FacePersistency != nil {
		buf[pos] = byte(133)
		pos += 1
		switch x := *value.FacePersistency; {
		case x <= 0xff:
			buf[pos] = 1
			buf[pos+1] = byte(x)
			pos += 2
		case x <= 0xffff:
			buf[pos] = 2
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 4
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 8
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
	}
	if value.LinkType != nil {
		buf[pos] = byte(134)
		pos += 1
		switch x := *value.LinkType; {
		case x <= 0xff:
			buf[pos] = 1
			buf[pos+1] = byte(x)
			pos += 2
		case x <= 0xffff:
			buf[pos] = 2
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 4
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 8
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
	}
}

func (encoder *FaceQueryFilterValueEncoder) Encode(value *FaceQueryFilterValue) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *FaceQueryFilterValueParsingContext) Parse(reader enc.ParseReader, ignoreCritical bool) (*FaceQueryFilterValue, error) {
	if reader == nil {
		return nil, enc.ErrBufferOverflow
	}

	var handled_FaceId bool = false
	var handled_UriScheme bool = false
	var handled_Uri bool = false
	var handled_LocalUri bool = false
	var handled_FaceScope bool = false
	var handled_FacePersistency bool = false
	var handled_LinkType bool = false

	progress := -1
	_ = progress

	value := &FaceQueryFilterValue{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 105:
				if true {
					handled = true
					handled_FaceId = true
					{
						tempVal := uint64(0)
						tempVal = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								tempVal = uint64(tempVal<<8) | uint64(x)
							}
						}
						value.FaceId = &tempVal
					}
				}
			case 131:
				if true {
					handled = true
					handled_UriScheme = true
					{
						var builder strings.Builder
						_, err = io.CopyN(&builder, reader, int64(l))
						if err == nil {
							tempStr := builder.String()
							value.UriScheme = &tempStr
						}
					}
				}
			case 114:
				if true {
					handled = true
					handled_Uri = true
					{
						var builder strings.Builder
						_, err = io.CopyN(&builder, reader, int64(l))
						if err == nil {
							tempStr := builder.String()
							value.Uri = &tempStr
						}
					}
				}
			case 129:
				if true {
					handled = true
					handled_LocalUri = true
					{
						var builder strings.Builder
						_, err = io.CopyN(&builder, reader, int64(l))
						if err == nil {
							tempStr := builder.String()
							value.LocalUri = &tempStr
						}
					}
				}
			case 132:
				if true {
					handled = true
					handled_FaceScope = true
					{
						tempVal := uint64(0)
						tempVal = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								tempVal = uint64(tempVal<<8) | uint64(x)
							}
						}
						value.FaceScope = &tempVal
					}
				}
			case 133:
				if true {
					handled = true
					handled_FacePersistency = true
					{
						tempVal := uint64(0)
						tempVal = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								tempVal = uint64(tempVal<<8) | uint64(x)
							}
						}
						value.FacePersistency = &tempVal
					}
				}
			case 134:
				if true {
					handled = true
					handled_LinkType = true
					{
						tempVal := uint64(0)
						tempVal = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								tempVal = uint64(tempVal<<8) | uint64(x)
							}
						}
						value.LinkType = &tempVal
					}
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_FaceId && err == nil {
		value.FaceId = nil
	}
	if !handled_UriScheme && err == nil {
		value.UriScheme = nil
	}
	if !handled_Uri && err == nil {
		value.Uri = nil
	}
	if !handled_LocalUri && err == nil {
		value.LocalUri = nil
	}
	if !handled_FaceScope && err == nil {
		value.FaceScope = nil
	}
	if !handled_FacePersistency && err == nil {
		value.FacePersistency = nil
	}
	if !handled_LinkType && err == nil {
		value.LinkType = nil
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *FaceQueryFilterValue) Encode() enc.Wire {
	encoder := FaceQueryFilterValueEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *FaceQueryFilterValue) Bytes() []byte {
	return value.Encode().Join()
}

func ParseFaceQueryFilterValue(reader enc.ParseReader, ignoreCritical bool) (*FaceQueryFilterValue, error) {
	context := FaceQueryFilterValueParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type FaceQueryFilterEncoder struct {
	length uint

	Val_encoder FaceQueryFilterValueEncoder
}

type FaceQueryFilterParsingContext struct {
	Val_context FaceQueryFilterValueParsingContext
}

func (encoder *FaceQueryFilterEncoder) Init(value *FaceQueryFilter) {
	if value.Val != nil {
		encoder.Val_encoder.Init(value.Val)
	}

	l := uint(0)
	if value.Val != nil {
		l += 1
		switch x := encoder.Val_encoder.length; {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		l += encoder.Val_encoder.length
	}
	encoder.length = l

}

func (context *FaceQueryFilterParsingContext) Init() {
	context.Val_context.Init()
}

func (encoder *FaceQueryFilterEncoder) EncodeInto(value *FaceQueryFilter, buf []byte) {

	pos := uint(0)

	if value.Val != nil {
		buf[pos] = byte(150)
		pos += 1
		switch x := encoder.Val_encoder.length; {
		case x <= 0xfc:
			buf[pos] = byte(x)
			pos += 1
		case x <= 0xffff:
			buf[pos] = 0xfd
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 0xfe
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 0xff
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
		if encoder.Val_encoder.length > 0 {
			encoder.Val_encoder.EncodeInto(value.Val, buf[pos:])
			pos += encoder.Val_encoder.length
		}
	}
}

func (encoder *FaceQueryFilterEncoder) Encode(value *FaceQueryFilter) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *FaceQueryFilterParsingContext) Parse(reader enc.ParseReader, ignoreCritical bool) (*FaceQueryFilter, error) {
	if reader == nil {
		return nil, enc.ErrBufferOverflow
	}

	var handled_Val bool = false

	progress := -1
	_ = progress

	value := &FaceQueryFilter{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 150:
				if true {
					handled = true
					handled_Val = true
					value.Val, err = context.Val_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Val && err == nil {
		value.Val = nil
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *FaceQueryFilter) Encode() enc.Wire {
	encoder := FaceQueryFilterEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *FaceQueryFilter) Bytes() []byte {
	return value.Encode().Join()
}

func ParseFaceQueryFilter(reader enc.ParseReader, ignoreCritical bool) (*FaceQueryFilter, error) {
	context := FaceQueryFilterParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type RouteEncoder struct {
	length uint
}

type RouteParsingContext struct {
}

func (encoder *RouteEncoder) Init(value *Route) {

	l := uint(0)
	l += 1
	switch x := value.FaceId; {
	case x <= 0xff:
		l += 2
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	l += 1
	switch x := value.Origin; {
	case x <= 0xff:
		l += 2
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	l += 1
	switch x := value.Cost; {
	case x <= 0xff:
		l += 2
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	l += 1
	switch x := value.Flags; {
	case x <= 0xff:
		l += 2
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	if value.ExpirationPeriod != nil {
		l += 1
		switch x := *value.ExpirationPeriod; {
		case x <= 0xff:
			l += 2
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
	}
	encoder.length = l

}

func (context *RouteParsingContext) Init() {

}

func (encoder *RouteEncoder) EncodeInto(value *Route, buf []byte) {

	pos := uint(0)

	buf[pos] = byte(105)
	pos += 1
	switch x := value.FaceId; {
	case x <= 0xff:
		buf[pos] = 1
		buf[pos+1] = byte(x)
		pos += 2
	case x <= 0xffff:
		buf[pos] = 2
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 4
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 8
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
	buf[pos] = byte(111)
	pos += 1
	switch x := value.Origin; {
	case x <= 0xff:
		buf[pos] = 1
		buf[pos+1] = byte(x)
		pos += 2
	case x <= 0xffff:
		buf[pos] = 2
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 4
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 8
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
	buf[pos] = byte(106)
	pos += 1
	switch x := value.Cost; {
	case x <= 0xff:
		buf[pos] = 1
		buf[pos+1] = byte(x)
		pos += 2
	case x <= 0xffff:
		buf[pos] = 2
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 4
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 8
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
	buf[pos] = byte(108)
	pos += 1
	switch x := value.Flags; {
	case x <= 0xff:
		buf[pos] = 1
		buf[pos+1] = byte(x)
		pos += 2
	case x <= 0xffff:
		buf[pos] = 2
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 4
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 8
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
	if value.ExpirationPeriod != nil {
		buf[pos] = byte(109)
		pos += 1
		switch x := *value.ExpirationPeriod; {
		case x <= 0xff:
			buf[pos] = 1
			buf[pos+1] = byte(x)
			pos += 2
		case x <= 0xffff:
			buf[pos] = 2
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 4
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 8
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
	}
}

func (encoder *RouteEncoder) Encode(value *Route) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *RouteParsingContext) Parse(reader enc.ParseReader, ignoreCritical bool) (*Route, error) {
	if reader == nil {
		return nil, enc.ErrBufferOverflow
	}

	var handled_FaceId bool = false
	var handled_Origin bool = false
	var handled_Cost bool = false
	var handled_Flags bool = false
	var handled_ExpirationPeriod bool = false

	progress := -1
	_ = progress

	value := &Route{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 105:
				if true {
					handled = true
					handled_FaceId = true
					value.FaceId = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.FaceId = uint64(value.FaceId<<8) | uint64(x)
						}
					}
				}
			case 111:
				if true {
					handled = true
					handled_Origin = true
					value.Origin = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.Origin = uint64(value.Origin<<8) | uint64(x)
						}
					}
				}
			case 106:
				if true {
					handled = true
					handled_Cost = true
					value.Cost = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.Cost = uint64(value.Cost<<8) | uint64(x)
						}
					}
				}
			case 108:
				if true {
					handled = true
					handled_Flags = true
					value.Flags = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.Flags = uint64(value.Flags<<8) | uint64(x)
						}
					}
				}
			case 109:
				if true {
					handled = true
					handled_ExpirationPeriod = true
					{
						tempVal := uint64(0)
						tempVal = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								tempVal = uint64(tempVal<<8) | uint64(x)
							}
						}
						value.ExpirationPeriod = &tempVal
					}
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_FaceId && err == nil {
		err = enc.ErrSkipRequired{Name: "FaceId", TypeNum: 105}
	}
	if !handled_Origin && err == nil {
		err = enc.ErrSkipRequired{Name: "Origin", TypeNum: 111}
	}
	if !handled_Cost && err == nil {
		err = enc.ErrSkipRequired{Name: "Cost", TypeNum: 106}
	}
	if !handled_Flags && err == nil {
		err = enc.ErrSkipRequired{Name: "Flags", TypeNum: 108}
	}
	if !handled_ExpirationPeriod && err == nil {
		value.ExpirationPeriod = nil
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *Route) Encode() enc.Wire {
	encoder := RouteEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *Route) Bytes() []byte {
	return value.Encode().Join()
}

func ParseRoute(reader enc.ParseReader, ignoreCritical bool) (*Route, error) {
	context := RouteParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type RibEntryEncoder struct {
	length uint

	Name_length       uint
	Routes_subencoder []struct {
		Routes_encoder RouteEncoder
	}
}

type RibEntryParsingContext struct {
	Routes_context RouteParsingContext
}

func (encoder *RibEntryEncoder) Init(value *RibEntry) {
	if value.Name != nil {
		encoder.Name_length = 0
		for _, c := range value.Name {
			encoder.Name_length += uint(c.EncodingLength())
		}
	}
	{
		Routes_l := len(value.Routes)
		encoder.Routes_subencoder = make([]struct {
			Routes_encoder RouteEncoder
		}, Routes_l)
		for i := 0; i < Routes_l; i++ {
			pseudoEncoder := &encoder.Routes_subencoder[i]
			pseudoValue := struct {
				Routes *Route
			}{
				Routes: value.Routes[i],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Routes != nil {
					encoder.Routes_encoder.Init(value.Routes)
				}
				_ = encoder
				_ = value
			}
		}
	}

	l := uint(0)
	if value.Name != nil {
		l += 1
		switch x := encoder.Name_length; {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		l += encoder.Name_length
	}
	if value.Routes != nil {
		for seq_i, seq_v := range value.Routes {
			pseudoEncoder := &encoder.Routes_subencoder[seq_i]
			pseudoValue := struct {
				Routes *Route
			}{
				Routes: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Routes != nil {
					l += 1
					switch x := encoder.Routes_encoder.length; {
					case x <= 0xfc:
						l += 1
					case x <= 0xffff:
						l += 3
					case x <= 0xffffffff:
						l += 5
					default:
						l += 9
					}
					l += encoder.Routes_encoder.length
				}
				_ = encoder
				_ = value
			}
		}
	}
	encoder.length = l

}

func (context *RibEntryParsingContext) Init() {

	context.Routes_context.Init()
}

func (encoder *RibEntryEncoder) EncodeInto(value *RibEntry, buf []byte) {

	pos := uint(0)

	if value.Name != nil {
		buf[pos] = byte(7)
		pos += 1
		switch x := encoder.Name_length; {
		case x <= 0xfc:
			buf[pos] = byte(x)
			pos += 1
		case x <= 0xffff:
			buf[pos] = 0xfd
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 0xfe
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 0xff
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
		for _, c := range value.Name {
			pos += uint(c.EncodeInto(buf[pos:]))
		}
	}
	if value.Routes != nil {
		for seq_i, seq_v := range value.Routes {
			pseudoEncoder := &encoder.Routes_subencoder[seq_i]
			pseudoValue := struct {
				Routes *Route
			}{
				Routes: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Routes != nil {
					buf[pos] = byte(129)
					pos += 1
					switch x := encoder.Routes_encoder.length; {
					case x <= 0xfc:
						buf[pos] = byte(x)
						pos += 1
					case x <= 0xffff:
						buf[pos] = 0xfd
						binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
						pos += 3
					case x <= 0xffffffff:
						buf[pos] = 0xfe
						binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
						pos += 5
					default:
						buf[pos] = 0xff
						binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
						pos += 9
					}
					if encoder.Routes_encoder.length > 0 {
						encoder.Routes_encoder.EncodeInto(value.Routes, buf[pos:])
						pos += encoder.Routes_encoder.length
					}
				}
				_ = encoder
				_ = value
			}
		}
	}
}

func (encoder *RibEntryEncoder) Encode(value *RibEntry) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *RibEntryParsingContext) Parse(reader enc.ParseReader, ignoreCritical bool) (*RibEntry, error) {
	if reader == nil {
		return nil, enc.ErrBufferOverflow
	}

	var handled_Name bool = false
	var handled_Routes bool = false

	progress := -1
	_ = progress

	value := &RibEntry{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 7:
				if true {
					handled = true
					handled_Name = true
					value.Name = make(enc.Name, l/2+1)
					startName := reader.Pos()
					endName := startName + int(l)
					for j := range value.Name {
						if reader.Pos() >= endName {
							value.Name = value.Name[:j]
							break
						}
						var err1, err3 error
						value.Name[j].Typ, err1 = enc.ReadTLNum(reader)
						l, err2 := enc.ReadTLNum(reader)
						value.Name[j].Val, err3 = reader.ReadBuf(int(l))
						if err1 != nil || err2 != nil || err3 != nil {
							err = io.ErrUnexpectedEOF
							break
						}
					}
					if err == nil && reader.Pos() != endName {
						err = enc.ErrBufferOverflow
					}
				}
			case 129:
				if true {
					handled = true
					handled_Routes = true
					if value.Routes == nil {
						value.Routes = make([]*Route, 0)
					}
					{
						pseudoValue := struct {
							Routes *Route
						}{}
						{
							value := &pseudoValue
							value.Routes, err = context.Routes_context.Parse(reader.Delegate(int(l)), ignoreCritical)
							_ = value
						}
						value.Routes = append(value.Routes, pseudoValue.Routes)
					}
					progress--
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Name && err == nil {
		value.Name = nil
	}
	if !handled_Routes && err == nil {
		// sequence - skip
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *RibEntry) Encode() enc.Wire {
	encoder := RibEntryEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *RibEntry) Bytes() []byte {
	return value.Encode().Join()
}

func ParseRibEntry(reader enc.ParseReader, ignoreCritical bool) (*RibEntry, error) {
	context := RibEntryParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type RibStatusEncoder struct {
	length uint

	Entries_subencoder []struct {
		Entries_encoder RibEntryEncoder
	}
}

type RibStatusParsingContext struct {
	Entries_context RibEntryParsingContext
}

func (encoder *RibStatusEncoder) Init(value *RibStatus) {
	{
		Entries_l := len(value.Entries)
		encoder.Entries_subencoder = make([]struct {
			Entries_encoder RibEntryEncoder
		}, Entries_l)
		for i := 0; i < Entries_l; i++ {
			pseudoEncoder := &encoder.Entries_subencoder[i]
			pseudoValue := struct {
				Entries *RibEntry
			}{
				Entries: value.Entries[i],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Entries != nil {
					encoder.Entries_encoder.Init(value.Entries)
				}
				_ = encoder
				_ = value
			}
		}
	}

	l := uint(0)
	if value.Entries != nil {
		for seq_i, seq_v := range value.Entries {
			pseudoEncoder := &encoder.Entries_subencoder[seq_i]
			pseudoValue := struct {
				Entries *RibEntry
			}{
				Entries: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Entries != nil {
					l += 1
					switch x := encoder.Entries_encoder.length; {
					case x <= 0xfc:
						l += 1
					case x <= 0xffff:
						l += 3
					case x <= 0xffffffff:
						l += 5
					default:
						l += 9
					}
					l += encoder.Entries_encoder.length
				}
				_ = encoder
				_ = value
			}
		}
	}
	encoder.length = l

}

func (context *RibStatusParsingContext) Init() {
	context.Entries_context.Init()
}

func (encoder *RibStatusEncoder) EncodeInto(value *RibStatus, buf []byte) {

	pos := uint(0)

	if value.Entries != nil {
		for seq_i, seq_v := range value.Entries {
			pseudoEncoder := &encoder.Entries_subencoder[seq_i]
			pseudoValue := struct {
				Entries *RibEntry
			}{
				Entries: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Entries != nil {
					buf[pos] = byte(128)
					pos += 1
					switch x := encoder.Entries_encoder.length; {
					case x <= 0xfc:
						buf[pos] = byte(x)
						pos += 1
					case x <= 0xffff:
						buf[pos] = 0xfd
						binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
						pos += 3
					case x <= 0xffffffff:
						buf[pos] = 0xfe
						binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
						pos += 5
					default:
						buf[pos] = 0xff
						binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
						pos += 9
					}
					if encoder.Entries_encoder.length > 0 {
						encoder.Entries_encoder.EncodeInto(value.Entries, buf[pos:])
						pos += encoder.Entries_encoder.length
					}
				}
				_ = encoder
				_ = value
			}
		}
	}
}

func (encoder *RibStatusEncoder) Encode(value *RibStatus) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *RibStatusParsingContext) Parse(reader enc.ParseReader, ignoreCritical bool) (*RibStatus, error) {
	if reader == nil {
		return nil, enc.ErrBufferOverflow
	}

	var handled_Entries bool = false

	progress := -1
	_ = progress

	value := &RibStatus{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 128:
				if true {
					handled = true
					handled_Entries = true
					if value.Entries == nil {
						value.Entries = make([]*RibEntry, 0)
					}
					{
						pseudoValue := struct {
							Entries *RibEntry
						}{}
						{
							value := &pseudoValue
							value.Entries, err = context.Entries_context.Parse(reader.Delegate(int(l)), ignoreCritical)
							_ = value
						}
						value.Entries = append(value.Entries, pseudoValue.Entries)
					}
					progress--
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Entries && err == nil {
		// sequence - skip
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *RibStatus) Encode() enc.Wire {
	encoder := RibStatusEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *RibStatus) Bytes() []byte {
	return value.Encode().Join()
}

func ParseRibStatus(reader enc.ParseReader, ignoreCritical bool) (*RibStatus, error) {
	context := RibStatusParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type NextHopRecordEncoder struct {
	length uint
}

type NextHopRecordParsingContext struct {
}

func (encoder *NextHopRecordEncoder) Init(value *NextHopRecord) {

	l := uint(0)
	l += 1
	switch x := value.FaceId; {
	case x <= 0xff:
		l += 2
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	l += 1
	switch x := value.Cost; {
	case x <= 0xff:
		l += 2
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	encoder.length = l

}

func (context *NextHopRecordParsingContext) Init() {

}

func (encoder *NextHopRecordEncoder) EncodeInto(value *NextHopRecord, buf []byte) {

	pos := uint(0)

	buf[pos] = byte(105)
	pos += 1
	switch x := value.FaceId; {
	case x <= 0xff:
		buf[pos] = 1
		buf[pos+1] = byte(x)
		pos += 2
	case x <= 0xffff:
		buf[pos] = 2
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 4
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 8
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
	buf[pos] = byte(106)
	pos += 1
	switch x := value.Cost; {
	case x <= 0xff:
		buf[pos] = 1
		buf[pos+1] = byte(x)
		pos += 2
	case x <= 0xffff:
		buf[pos] = 2
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 4
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 8
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
}

func (encoder *NextHopRecordEncoder) Encode(value *NextHopRecord) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *NextHopRecordParsingContext) Parse(reader enc.ParseReader, ignoreCritical bool) (*NextHopRecord, error) {
	if reader == nil {
		return nil, enc.ErrBufferOverflow
	}

	var handled_FaceId bool = false
	var handled_Cost bool = false

	progress := -1
	_ = progress

	value := &NextHopRecord{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 105:
				if true {
					handled = true
					handled_FaceId = true
					value.FaceId = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.FaceId = uint64(value.FaceId<<8) | uint64(x)
						}
					}
				}
			case 106:
				if true {
					handled = true
					handled_Cost = true
					value.Cost = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.Cost = uint64(value.Cost<<8) | uint64(x)
						}
					}
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_FaceId && err == nil {
		err = enc.ErrSkipRequired{Name: "FaceId", TypeNum: 105}
	}
	if !handled_Cost && err == nil {
		err = enc.ErrSkipRequired{Name: "Cost", TypeNum: 106}
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *NextHopRecord) Encode() enc.Wire {
	encoder := NextHopRecordEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *NextHopRecord) Bytes() []byte {
	return value.Encode().Join()
}

func ParseNextHopRecord(reader enc.ParseReader, ignoreCritical bool) (*NextHopRecord, error) {
	context := NextHopRecordParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type FibEntryEncoder struct {
	length uint

	Name_length               uint
	NextHopRecords_subencoder []struct {
		NextHopRecords_encoder NextHopRecordEncoder
	}
}

type FibEntryParsingContext struct {
	NextHopRecords_context NextHopRecordParsingContext
}

func (encoder *FibEntryEncoder) Init(value *FibEntry) {
	if value.Name != nil {
		encoder.Name_length = 0
		for _, c := range value.Name {
			encoder.Name_length += uint(c.EncodingLength())
		}
	}
	{
		NextHopRecords_l := len(value.NextHopRecords)
		encoder.NextHopRecords_subencoder = make([]struct {
			NextHopRecords_encoder NextHopRecordEncoder
		}, NextHopRecords_l)
		for i := 0; i < NextHopRecords_l; i++ {
			pseudoEncoder := &encoder.NextHopRecords_subencoder[i]
			pseudoValue := struct {
				NextHopRecords *NextHopRecord
			}{
				NextHopRecords: value.NextHopRecords[i],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.NextHopRecords != nil {
					encoder.NextHopRecords_encoder.Init(value.NextHopRecords)
				}
				_ = encoder
				_ = value
			}
		}
	}

	l := uint(0)
	if value.Name != nil {
		l += 1
		switch x := encoder.Name_length; {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		l += encoder.Name_length
	}
	if value.NextHopRecords != nil {
		for seq_i, seq_v := range value.NextHopRecords {
			pseudoEncoder := &encoder.NextHopRecords_subencoder[seq_i]
			pseudoValue := struct {
				NextHopRecords *NextHopRecord
			}{
				NextHopRecords: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.NextHopRecords != nil {
					l += 1
					switch x := encoder.NextHopRecords_encoder.length; {
					case x <= 0xfc:
						l += 1
					case x <= 0xffff:
						l += 3
					case x <= 0xffffffff:
						l += 5
					default:
						l += 9
					}
					l += encoder.NextHopRecords_encoder.length
				}
				_ = encoder
				_ = value
			}
		}
	}
	encoder.length = l

}

func (context *FibEntryParsingContext) Init() {

	context.NextHopRecords_context.Init()
}

func (encoder *FibEntryEncoder) EncodeInto(value *FibEntry, buf []byte) {

	pos := uint(0)

	if value.Name != nil {
		buf[pos] = byte(7)
		pos += 1
		switch x := encoder.Name_length; {
		case x <= 0xfc:
			buf[pos] = byte(x)
			pos += 1
		case x <= 0xffff:
			buf[pos] = 0xfd
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 0xfe
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 0xff
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
		for _, c := range value.Name {
			pos += uint(c.EncodeInto(buf[pos:]))
		}
	}
	if value.NextHopRecords != nil {
		for seq_i, seq_v := range value.NextHopRecords {
			pseudoEncoder := &encoder.NextHopRecords_subencoder[seq_i]
			pseudoValue := struct {
				NextHopRecords *NextHopRecord
			}{
				NextHopRecords: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.NextHopRecords != nil {
					buf[pos] = byte(129)
					pos += 1
					switch x := encoder.NextHopRecords_encoder.length; {
					case x <= 0xfc:
						buf[pos] = byte(x)
						pos += 1
					case x <= 0xffff:
						buf[pos] = 0xfd
						binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
						pos += 3
					case x <= 0xffffffff:
						buf[pos] = 0xfe
						binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
						pos += 5
					default:
						buf[pos] = 0xff
						binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
						pos += 9
					}
					if encoder.NextHopRecords_encoder.length > 0 {
						encoder.NextHopRecords_encoder.EncodeInto(value.NextHopRecords, buf[pos:])
						pos += encoder.NextHopRecords_encoder.length
					}
				}
				_ = encoder
				_ = value
			}
		}
	}
}

func (encoder *FibEntryEncoder) Encode(value *FibEntry) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *FibEntryParsingContext) Parse(reader enc.ParseReader, ignoreCritical bool) (*FibEntry, error) {
	if reader == nil {
		return nil, enc.ErrBufferOverflow
	}

	var handled_Name bool = false
	var handled_NextHopRecords bool = false

	progress := -1
	_ = progress

	value := &FibEntry{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 7:
				if true {
					handled = true
					handled_Name = true
					value.Name = make(enc.Name, l/2+1)
					startName := reader.Pos()
					endName := startName + int(l)
					for j := range value.Name {
						if reader.Pos() >= endName {
							value.Name = value.Name[:j]
							break
						}
						var err1, err3 error
						value.Name[j].Typ, err1 = enc.ReadTLNum(reader)
						l, err2 := enc.ReadTLNum(reader)
						value.Name[j].Val, err3 = reader.ReadBuf(int(l))
						if err1 != nil || err2 != nil || err3 != nil {
							err = io.ErrUnexpectedEOF
							break
						}
					}
					if err == nil && reader.Pos() != endName {
						err = enc.ErrBufferOverflow
					}
				}
			case 129:
				if true {
					handled = true
					handled_NextHopRecords = true
					if value.NextHopRecords == nil {
						value.NextHopRecords = make([]*NextHopRecord, 0)
					}
					{
						pseudoValue := struct {
							NextHopRecords *NextHopRecord
						}{}
						{
							value := &pseudoValue
							value.NextHopRecords, err = context.NextHopRecords_context.Parse(reader.Delegate(int(l)), ignoreCritical)
							_ = value
						}
						value.NextHopRecords = append(value.NextHopRecords, pseudoValue.NextHopRecords)
					}
					progress--
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Name && err == nil {
		value.Name = nil
	}
	if !handled_NextHopRecords && err == nil {
		// sequence - skip
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *FibEntry) Encode() enc.Wire {
	encoder := FibEntryEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *FibEntry) Bytes() []byte {
	return value.Encode().Join()
}

func ParseFibEntry(reader enc.ParseReader, ignoreCritical bool) (*FibEntry, error) {
	context := FibEntryParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type FibStatusEncoder struct {
	length uint

	Entries_subencoder []struct {
		Entries_encoder FibEntryEncoder
	}
}

type FibStatusParsingContext struct {
	Entries_context FibEntryParsingContext
}

func (encoder *FibStatusEncoder) Init(value *FibStatus) {
	{
		Entries_l := len(value.Entries)
		encoder.Entries_subencoder = make([]struct {
			Entries_encoder FibEntryEncoder
		}, Entries_l)
		for i := 0; i < Entries_l; i++ {
			pseudoEncoder := &encoder.Entries_subencoder[i]
			pseudoValue := struct {
				Entries *FibEntry
			}{
				Entries: value.Entries[i],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Entries != nil {
					encoder.Entries_encoder.Init(value.Entries)
				}
				_ = encoder
				_ = value
			}
		}
	}

	l := uint(0)
	if value.Entries != nil {
		for seq_i, seq_v := range value.Entries {
			pseudoEncoder := &encoder.Entries_subencoder[seq_i]
			pseudoValue := struct {
				Entries *FibEntry
			}{
				Entries: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Entries != nil {
					l += 1
					switch x := encoder.Entries_encoder.length; {
					case x <= 0xfc:
						l += 1
					case x <= 0xffff:
						l += 3
					case x <= 0xffffffff:
						l += 5
					default:
						l += 9
					}
					l += encoder.Entries_encoder.length
				}
				_ = encoder
				_ = value
			}
		}
	}
	encoder.length = l

}

func (context *FibStatusParsingContext) Init() {
	context.Entries_context.Init()
}

func (encoder *FibStatusEncoder) EncodeInto(value *FibStatus, buf []byte) {

	pos := uint(0)

	if value.Entries != nil {
		for seq_i, seq_v := range value.Entries {
			pseudoEncoder := &encoder.Entries_subencoder[seq_i]
			pseudoValue := struct {
				Entries *FibEntry
			}{
				Entries: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Entries != nil {
					buf[pos] = byte(128)
					pos += 1
					switch x := encoder.Entries_encoder.length; {
					case x <= 0xfc:
						buf[pos] = byte(x)
						pos += 1
					case x <= 0xffff:
						buf[pos] = 0xfd
						binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
						pos += 3
					case x <= 0xffffffff:
						buf[pos] = 0xfe
						binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
						pos += 5
					default:
						buf[pos] = 0xff
						binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
						pos += 9
					}
					if encoder.Entries_encoder.length > 0 {
						encoder.Entries_encoder.EncodeInto(value.Entries, buf[pos:])
						pos += encoder.Entries_encoder.length
					}
				}
				_ = encoder
				_ = value
			}
		}
	}
}

func (encoder *FibStatusEncoder) Encode(value *FibStatus) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *FibStatusParsingContext) Parse(reader enc.ParseReader, ignoreCritical bool) (*FibStatus, error) {
	if reader == nil {
		return nil, enc.ErrBufferOverflow
	}

	var handled_Entries bool = false

	progress := -1
	_ = progress

	value := &FibStatus{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 128:
				if true {
					handled = true
					handled_Entries = true
					if value.Entries == nil {
						value.Entries = make([]*FibEntry, 0)
					}
					{
						pseudoValue := struct {
							Entries *FibEntry
						}{}
						{
							value := &pseudoValue
							value.Entries, err = context.Entries_context.Parse(reader.Delegate(int(l)), ignoreCritical)
							_ = value
						}
						value.Entries = append(value.Entries, pseudoValue.Entries)
					}
					progress--
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Entries && err == nil {
		// sequence - skip
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *FibStatus) Encode() enc.Wire {
	encoder := FibStatusEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *FibStatus) Bytes() []byte {
	return value.Encode().Join()
}

func ParseFibStatus(reader enc.ParseReader, ignoreCritical bool) (*FibStatus, error) {
	context := FibStatusParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type StrategyChoiceEncoder struct {
	length uint

	Name_length      uint
	Strategy_encoder StrategyEncoder
}

type StrategyChoiceParsingContext struct {
	Strategy_context StrategyParsingContext
}

func (encoder *StrategyChoiceEncoder) Init(value *StrategyChoice) {
	if value.Name != nil {
		encoder.Name_length = 0
		for _, c := range value.Name {
			encoder.Name_length += uint(c.EncodingLength())
		}
	}
	if value.Strategy != nil {
		encoder.Strategy_encoder.Init(value.Strategy)
	}

	l := uint(0)
	if value.Name != nil {
		l += 1
		switch x := encoder.Name_length; {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		l += encoder.Name_length
	}
	if value.Strategy != nil {
		l += 1
		switch x := encoder.Strategy_encoder.length; {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		l += encoder.Strategy_encoder.length
	}
	encoder.length = l

}

func (context *StrategyChoiceParsingContext) Init() {

	context.Strategy_context.Init()
}

func (encoder *StrategyChoiceEncoder) EncodeInto(value *StrategyChoice, buf []byte) {

	pos := uint(0)

	if value.Name != nil {
		buf[pos] = byte(7)
		pos += 1
		switch x := encoder.Name_length; {
		case x <= 0xfc:
			buf[pos] = byte(x)
			pos += 1
		case x <= 0xffff:
			buf[pos] = 0xfd
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 0xfe
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 0xff
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
		for _, c := range value.Name {
			pos += uint(c.EncodeInto(buf[pos:]))
		}
	}
	if value.Strategy != nil {
		buf[pos] = byte(107)
		pos += 1
		switch x := encoder.Strategy_encoder.length; {
		case x <= 0xfc:
			buf[pos] = byte(x)
			pos += 1
		case x <= 0xffff:
			buf[pos] = 0xfd
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 0xfe
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 0xff
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
		if encoder.Strategy_encoder.length > 0 {
			encoder.Strategy_encoder.EncodeInto(value.Strategy, buf[pos:])
			pos += encoder.Strategy_encoder.length
		}
	}
}

func (encoder *StrategyChoiceEncoder) Encode(value *StrategyChoice) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *StrategyChoiceParsingContext) Parse(reader enc.ParseReader, ignoreCritical bool) (*StrategyChoice, error) {
	if reader == nil {
		return nil, enc.ErrBufferOverflow
	}

	var handled_Name bool = false
	var handled_Strategy bool = false

	progress := -1
	_ = progress

	value := &StrategyChoice{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 7:
				if true {
					handled = true
					handled_Name = true
					value.Name = make(enc.Name, l/2+1)
					startName := reader.Pos()
					endName := startName + int(l)
					for j := range value.Name {
						if reader.Pos() >= endName {
							value.Name = value.Name[:j]
							break
						}
						var err1, err3 error
						value.Name[j].Typ, err1 = enc.ReadTLNum(reader)
						l, err2 := enc.ReadTLNum(reader)
						value.Name[j].Val, err3 = reader.ReadBuf(int(l))
						if err1 != nil || err2 != nil || err3 != nil {
							err = io.ErrUnexpectedEOF
							break
						}
					}
					if err == nil && reader.Pos() != endName {
						err = enc.ErrBufferOverflow
					}
				}
			case 107:
				if true {
					handled = true
					handled_Strategy = true
					value.Strategy, err = context.Strategy_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Name && err == nil {
		value.Name = nil
	}
	if !handled_Strategy && err == nil {
		value.Strategy = nil
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *StrategyChoice) Encode() enc.Wire {
	encoder := StrategyChoiceEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *StrategyChoice) Bytes() []byte {
	return value.Encode().Join()
}

func ParseStrategyChoice(reader enc.ParseReader, ignoreCritical bool) (*StrategyChoice, error) {
	context := StrategyChoiceParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type StrategyChoiceMsgEncoder struct {
	length uint

	StrategyChoices_subencoder []struct {
		StrategyChoices_encoder StrategyChoiceEncoder
	}
}

type StrategyChoiceMsgParsingContext struct {
	StrategyChoices_context StrategyChoiceParsingContext
}

func (encoder *StrategyChoiceMsgEncoder) Init(value *StrategyChoiceMsg) {
	{
		StrategyChoices_l := len(value.StrategyChoices)
		encoder.StrategyChoices_subencoder = make([]struct {
			StrategyChoices_encoder StrategyChoiceEncoder
		}, StrategyChoices_l)
		for i := 0; i < StrategyChoices_l; i++ {
			pseudoEncoder := &encoder.StrategyChoices_subencoder[i]
			pseudoValue := struct {
				StrategyChoices *StrategyChoice
			}{
				StrategyChoices: value.StrategyChoices[i],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.StrategyChoices != nil {
					encoder.StrategyChoices_encoder.Init(value.StrategyChoices)
				}
				_ = encoder
				_ = value
			}
		}
	}

	l := uint(0)
	if value.StrategyChoices != nil {
		for seq_i, seq_v := range value.StrategyChoices {
			pseudoEncoder := &encoder.StrategyChoices_subencoder[seq_i]
			pseudoValue := struct {
				StrategyChoices *StrategyChoice
			}{
				StrategyChoices: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.StrategyChoices != nil {
					l += 1
					switch x := encoder.StrategyChoices_encoder.length; {
					case x <= 0xfc:
						l += 1
					case x <= 0xffff:
						l += 3
					case x <= 0xffffffff:
						l += 5
					default:
						l += 9
					}
					l += encoder.StrategyChoices_encoder.length
				}
				_ = encoder
				_ = value
			}
		}
	}
	encoder.length = l

}

func (context *StrategyChoiceMsgParsingContext) Init() {
	context.StrategyChoices_context.Init()
}

func (encoder *StrategyChoiceMsgEncoder) EncodeInto(value *StrategyChoiceMsg, buf []byte) {

	pos := uint(0)

	if value.StrategyChoices != nil {
		for seq_i, seq_v := range value.StrategyChoices {
			pseudoEncoder := &encoder.StrategyChoices_subencoder[seq_i]
			pseudoValue := struct {
				StrategyChoices *StrategyChoice
			}{
				StrategyChoices: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.StrategyChoices != nil {
					buf[pos] = byte(128)
					pos += 1
					switch x := encoder.StrategyChoices_encoder.length; {
					case x <= 0xfc:
						buf[pos] = byte(x)
						pos += 1
					case x <= 0xffff:
						buf[pos] = 0xfd
						binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
						pos += 3
					case x <= 0xffffffff:
						buf[pos] = 0xfe
						binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
						pos += 5
					default:
						buf[pos] = 0xff
						binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
						pos += 9
					}
					if encoder.StrategyChoices_encoder.length > 0 {
						encoder.StrategyChoices_encoder.EncodeInto(value.StrategyChoices, buf[pos:])
						pos += encoder.StrategyChoices_encoder.length
					}
				}
				_ = encoder
				_ = value
			}
		}
	}
}

func (encoder *StrategyChoiceMsgEncoder) Encode(value *StrategyChoiceMsg) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *StrategyChoiceMsgParsingContext) Parse(reader enc.ParseReader, ignoreCritical bool) (*StrategyChoiceMsg, error) {
	if reader == nil {
		return nil, enc.ErrBufferOverflow
	}

	var handled_StrategyChoices bool = false

	progress := -1
	_ = progress

	value := &StrategyChoiceMsg{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 128:
				if true {
					handled = true
					handled_StrategyChoices = true
					if value.StrategyChoices == nil {
						value.StrategyChoices = make([]*StrategyChoice, 0)
					}
					{
						pseudoValue := struct {
							StrategyChoices *StrategyChoice
						}{}
						{
							value := &pseudoValue
							value.StrategyChoices, err = context.StrategyChoices_context.Parse(reader.Delegate(int(l)), ignoreCritical)
							_ = value
						}
						value.StrategyChoices = append(value.StrategyChoices, pseudoValue.StrategyChoices)
					}
					progress--
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_StrategyChoices && err == nil {
		// sequence - skip
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *StrategyChoiceMsg) Encode() enc.Wire {
	encoder := StrategyChoiceMsgEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *StrategyChoiceMsg) Bytes() []byte {
	return value.Encode().Join()
}

func ParseStrategyChoiceMsg(reader enc.ParseReader, ignoreCritical bool) (*StrategyChoiceMsg, error) {
	context := StrategyChoiceMsgParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type CsInfoEncoder struct {
	length uint
}

type CsInfoParsingContext struct {
}

func (encoder *CsInfoEncoder) Init(value *CsInfo) {

	l := uint(0)
	l += 1
	switch x := value.Capacity; {
	case x <= 0xff:
		l += 2
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	l += 1
	switch x := value.Flags; {
	case x <= 0xff:
		l += 2
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	l += 1
	switch x := value.NCsEntries; {
	case x <= 0xff:
		l += 2
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	l += 1
	switch x := value.NHits; {
	case x <= 0xff:
		l += 2
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	l += 1
	switch x := value.NMisses; {
	case x <= 0xff:
		l += 2
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	encoder.length = l

}

func (context *CsInfoParsingContext) Init() {

}

func (encoder *CsInfoEncoder) EncodeInto(value *CsInfo, buf []byte) {

	pos := uint(0)

	buf[pos] = byte(131)
	pos += 1
	switch x := value.Capacity; {
	case x <= 0xff:
		buf[pos] = 1
		buf[pos+1] = byte(x)
		pos += 2
	case x <= 0xffff:
		buf[pos] = 2
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 4
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 8
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
	buf[pos] = byte(108)
	pos += 1
	switch x := value.Flags; {
	case x <= 0xff:
		buf[pos] = 1
		buf[pos+1] = byte(x)
		pos += 2
	case x <= 0xffff:
		buf[pos] = 2
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 4
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 8
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
	buf[pos] = byte(135)
	pos += 1
	switch x := value.NCsEntries; {
	case x <= 0xff:
		buf[pos] = 1
		buf[pos+1] = byte(x)
		pos += 2
	case x <= 0xffff:
		buf[pos] = 2
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 4
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 8
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
	buf[pos] = byte(129)
	pos += 1
	switch x := value.NHits; {
	case x <= 0xff:
		buf[pos] = 1
		buf[pos+1] = byte(x)
		pos += 2
	case x <= 0xffff:
		buf[pos] = 2
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 4
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 8
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
	buf[pos] = byte(130)
	pos += 1
	switch x := value.NMisses; {
	case x <= 0xff:
		buf[pos] = 1
		buf[pos+1] = byte(x)
		pos += 2
	case x <= 0xffff:
		buf[pos] = 2
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 4
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 8
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
}

func (encoder *CsInfoEncoder) Encode(value *CsInfo) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *CsInfoParsingContext) Parse(reader enc.ParseReader, ignoreCritical bool) (*CsInfo, error) {
	if reader == nil {
		return nil, enc.ErrBufferOverflow
	}

	var handled_Capacity bool = false
	var handled_Flags bool = false
	var handled_NCsEntries bool = false
	var handled_NHits bool = false
	var handled_NMisses bool = false

	progress := -1
	_ = progress

	value := &CsInfo{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 131:
				if true {
					handled = true
					handled_Capacity = true
					value.Capacity = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.Capacity = uint64(value.Capacity<<8) | uint64(x)
						}
					}
				}
			case 108:
				if true {
					handled = true
					handled_Flags = true
					value.Flags = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.Flags = uint64(value.Flags<<8) | uint64(x)
						}
					}
				}
			case 135:
				if true {
					handled = true
					handled_NCsEntries = true
					value.NCsEntries = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.NCsEntries = uint64(value.NCsEntries<<8) | uint64(x)
						}
					}
				}
			case 129:
				if true {
					handled = true
					handled_NHits = true
					value.NHits = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.NHits = uint64(value.NHits<<8) | uint64(x)
						}
					}
				}
			case 130:
				if true {
					handled = true
					handled_NMisses = true
					value.NMisses = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.NMisses = uint64(value.NMisses<<8) | uint64(x)
						}
					}
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Capacity && err == nil {
		err = enc.ErrSkipRequired{Name: "Capacity", TypeNum: 131}
	}
	if !handled_Flags && err == nil {
		err = enc.ErrSkipRequired{Name: "Flags", TypeNum: 108}
	}
	if !handled_NCsEntries && err == nil {
		err = enc.ErrSkipRequired{Name: "NCsEntries", TypeNum: 135}
	}
	if !handled_NHits && err == nil {
		err = enc.ErrSkipRequired{Name: "NHits", TypeNum: 129}
	}
	if !handled_NMisses && err == nil {
		err = enc.ErrSkipRequired{Name: "NMisses", TypeNum: 130}
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *CsInfo) Encode() enc.Wire {
	encoder := CsInfoEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *CsInfo) Bytes() []byte {
	return value.Encode().Join()
}

func ParseCsInfo(reader enc.ParseReader, ignoreCritical bool) (*CsInfo, error) {
	context := CsInfoParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type CsInfoMsgEncoder struct {
	length uint

	CsInfo_encoder CsInfoEncoder
}

type CsInfoMsgParsingContext struct {
	CsInfo_context CsInfoParsingContext
}

func (encoder *CsInfoMsgEncoder) Init(value *CsInfoMsg) {
	if value.CsInfo != nil {
		encoder.CsInfo_encoder.Init(value.CsInfo)
	}

	l := uint(0)
	if value.CsInfo != nil {
		l += 1
		switch x := encoder.CsInfo_encoder.length; {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		l += encoder.CsInfo_encoder.length
	}
	encoder.length = l

}

func (context *CsInfoMsgParsingContext) Init() {
	context.CsInfo_context.Init()
}

func (encoder *CsInfoMsgEncoder) EncodeInto(value *CsInfoMsg, buf []byte) {

	pos := uint(0)

	if value.CsInfo != nil {
		buf[pos] = byte(128)
		pos += 1
		switch x := encoder.CsInfo_encoder.length; {
		case x <= 0xfc:
			buf[pos] = byte(x)
			pos += 1
		case x <= 0xffff:
			buf[pos] = 0xfd
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 0xfe
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 0xff
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
		if encoder.CsInfo_encoder.length > 0 {
			encoder.CsInfo_encoder.EncodeInto(value.CsInfo, buf[pos:])
			pos += encoder.CsInfo_encoder.length
		}
	}
}

func (encoder *CsInfoMsgEncoder) Encode(value *CsInfoMsg) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *CsInfoMsgParsingContext) Parse(reader enc.ParseReader, ignoreCritical bool) (*CsInfoMsg, error) {
	if reader == nil {
		return nil, enc.ErrBufferOverflow
	}

	var handled_CsInfo bool = false

	progress := -1
	_ = progress

	value := &CsInfoMsg{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 128:
				if true {
					handled = true
					handled_CsInfo = true
					value.CsInfo, err = context.CsInfo_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_CsInfo && err == nil {
		value.CsInfo = nil
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *CsInfoMsg) Encode() enc.Wire {
	encoder := CsInfoMsgEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *CsInfoMsg) Bytes() []byte {
	return value.Encode().Join()
}

func ParseCsInfoMsg(reader enc.ParseReader, ignoreCritical bool) (*CsInfoMsg, error) {
	context := CsInfoMsgParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}
