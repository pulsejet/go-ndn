// Generated by the generator, DO NOT modify manually
package spec_2022

import (
	"encoding/binary"
	"io"
	"strings"
	"time"

	enc "github.com/zjkmxy/go-ndn/pkg/encoding"
)

type KeyLocatorEncoder struct {
	length uint

	Name_length uint
}

type KeyLocatorParsingContext struct {
}

func (encoder *KeyLocatorEncoder) Init(value *KeyLocator) {
	if value.Name != nil {
		encoder.Name_length = 0
		for _, c := range value.Name {
			encoder.Name_length += uint(c.EncodingLength())
		}
	}

	l := uint(0)
	if value.Name != nil {
		l += 1
		switch x := encoder.Name_length; {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		l += encoder.Name_length
	}

	if value.KeyDigest != nil {
		l += 1
		switch x := len(value.KeyDigest); {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		l += uint(len(value.KeyDigest))
	}

	encoder.length = l

}

func (context *KeyLocatorParsingContext) Init() {

}

func (encoder *KeyLocatorEncoder) EncodeInto(value *KeyLocator, buf []byte) {

	pos := uint(0)
	if value.Name != nil {
		buf[pos] = byte(7)
		pos += 1
		switch x := encoder.Name_length; {
		case x <= 0xfc:
			buf[pos] = byte(x)
			pos += 1
		case x <= 0xffff:
			buf[pos] = 0xfd
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 0xfe
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 0xff
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
		for _, c := range value.Name {
			pos += uint(c.EncodeInto(buf[pos:]))
		}
	}

	if value.KeyDigest != nil {
		buf[pos] = byte(29)
		pos += 1
		switch x := len(value.KeyDigest); {
		case x <= 0xfc:
			buf[pos] = byte(x)
			pos += 1
		case x <= 0xffff:
			buf[pos] = 0xfd
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 0xfe
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 0xff
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
		copy(buf[pos:], value.KeyDigest)
		pos += uint(len(value.KeyDigest))
	}

}

func (encoder *KeyLocatorEncoder) Encode(value *KeyLocator) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *KeyLocatorParsingContext) Parse(reader enc.ParseReader, ignoreCritical bool) (*KeyLocator, error) {
	if reader == nil {
		return nil, enc.ErrBufferOverflow
	}
	progress := -1
	value := &KeyLocator{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		err = nil
		for handled := false; !handled; progress++ {
			switch typ {
			case 7:
				if progress+1 == 0 {
					handled = true
					value.Name = make(enc.Name, 0)
					startName := reader.Pos()
					endName := startName + int(l)
					for reader.Pos() < endName {
						c, err := enc.ReadComponent(reader)
						if err != nil {
							break
						}
						value.Name = append(value.Name, *c)
					}
					if err != nil && reader.Pos() != endName {
						err = enc.ErrBufferOverflow
					}

				}
			case 29:
				if progress+1 == 1 {
					handled = true
					value.KeyDigest = make([]byte, l)
					_, err = io.ReadFull(reader, value.KeyDigest)

				}
			default:
				handled = true
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
				switch progress {
				case 0 - 1:
					value.Name = nil
				case 1 - 1:
					value.KeyDigest = nil
				}
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}
	startPos = reader.Pos()
	for ; progress < 2; progress++ {
		switch progress {
		case 0 - 1:
			value.Name = nil
		case 1 - 1:
			value.KeyDigest = nil
		}
	}
	if err != nil {
		return nil, err
	}
	return value, nil
}

func (value *KeyLocator) Encode() enc.Wire {
	encoder := KeyLocatorEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *KeyLocator) Bytes() []byte {
	return value.Encode().Join()
}

func ParseKeyLocator(reader enc.ParseReader, ignoreCritical bool) (*KeyLocator, error) {
	context := KeyLocatorParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type LinksEncoder struct {
	length uint

	Names_subencoder []struct {
		Names_length uint
	}
}

type LinksParsingContext struct {
}

func (encoder *LinksEncoder) Init(value *Links) {
	{
		Names_l := len(value.Names)
		encoder.Names_subencoder = make([]struct {
			Names_length uint
		}, Names_l)
		for i := 0; i < Names_l; i++ {
			pseudoEncoder := &encoder.Names_subencoder[i]
			pseudoValue := struct {
				Names enc.Name
			}{
				Names: value.Names[i],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Names != nil {
					encoder.Names_length = 0
					for _, c := range value.Names {
						encoder.Names_length += uint(c.EncodingLength())
					}
				}

				_ = encoder
				_ = value
			}
		}
	}

	l := uint(0)
	if value.Names != nil {
		for seq_i, seq_v := range value.Names {
			pseudoEncoder := &encoder.Names_subencoder[seq_i]
			pseudoValue := struct {
				Names enc.Name
			}{
				Names: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Names != nil {
					l += 1
					switch x := encoder.Names_length; {
					case x <= 0xfc:
						l += 1
					case x <= 0xffff:
						l += 3
					case x <= 0xffffffff:
						l += 5
					default:
						l += 9
					}
					l += encoder.Names_length
				}

				_ = encoder
				_ = value
			}
		}
	}

	encoder.length = l

}

func (context *LinksParsingContext) Init() {

}

func (encoder *LinksEncoder) EncodeInto(value *Links, buf []byte) {

	pos := uint(0)
	if value.Names != nil {
		for seq_i, seq_v := range value.Names {
			pseudoEncoder := &encoder.Names_subencoder[seq_i]
			pseudoValue := struct {
				Names enc.Name
			}{
				Names: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Names != nil {
					buf[pos] = byte(7)
					pos += 1
					switch x := encoder.Names_length; {
					case x <= 0xfc:
						buf[pos] = byte(x)
						pos += 1
					case x <= 0xffff:
						buf[pos] = 0xfd
						binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
						pos += 3
					case x <= 0xffffffff:
						buf[pos] = 0xfe
						binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
						pos += 5
					default:
						buf[pos] = 0xff
						binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
						pos += 9
					}
					for _, c := range value.Names {
						pos += uint(c.EncodeInto(buf[pos:]))
					}
				}

				_ = encoder
				_ = value
			}
		}
	}

}

func (encoder *LinksEncoder) Encode(value *Links) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *LinksParsingContext) Parse(reader enc.ParseReader, ignoreCritical bool) (*Links, error) {
	if reader == nil {
		return nil, enc.ErrBufferOverflow
	}
	progress := -1
	value := &Links{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		err = nil
		for handled := false; !handled; progress++ {
			switch typ {
			case 7:
				if progress+1 == 0 {
					handled = true
					if value.Names == nil {
						value.Names = make([]enc.Name, 0)
					}
					{
						pseudoValue := struct {
							Names enc.Name
						}{}
						{
							value := &pseudoValue
							value.Names = make(enc.Name, 0)
							startName := reader.Pos()
							endName := startName + int(l)
							for reader.Pos() < endName {
								c, err := enc.ReadComponent(reader)
								if err != nil {
									break
								}
								value.Names = append(value.Names, *c)
							}
							if err != nil && reader.Pos() != endName {
								err = enc.ErrBufferOverflow
							}

							_ = value
						}
						value.Names = append(value.Names, pseudoValue.Names)
					}
					progress--

				}
			default:
				handled = true
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
				switch progress {
				case 0 - 1:

				}
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}
	startPos = reader.Pos()
	for ; progress < 1; progress++ {
		switch progress {
		case 0 - 1:

		}
	}
	if err != nil {
		return nil, err
	}
	return value, nil
}

func (value *Links) Encode() enc.Wire {
	encoder := LinksEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *Links) Bytes() []byte {
	return value.Encode().Join()
}

func ParseLinks(reader enc.ParseReader, ignoreCritical bool) (*Links, error) {
	context := LinksParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type MetaInfoEncoder struct {
	length uint
}

type MetaInfoParsingContext struct {
}

func (encoder *MetaInfoEncoder) Init(value *MetaInfo) {

	l := uint(0)
	if value.ContentType != nil {
		l += 1
		switch x := *value.ContentType; {
		case x <= 0xff:
			l += 2
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
	}

	if value.FreshnessPeriod != nil {
		l += 1
		switch x := uint64(*value.FreshnessPeriod / time.Millisecond); {
		case x <= 0xff:
			l += 2
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
	}

	if value.FinalBlockID != nil {
		l += 1
		switch x := len(value.FinalBlockID); {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		l += uint(len(value.FinalBlockID))
	}

	encoder.length = l

}

func (context *MetaInfoParsingContext) Init() {

}

func (encoder *MetaInfoEncoder) EncodeInto(value *MetaInfo, buf []byte) {

	pos := uint(0)
	if value.ContentType != nil {
		buf[pos] = byte(24)
		pos += 1
		switch x := *value.ContentType; {
		case x <= 0xff:
			buf[pos] = 1
			buf[pos+1] = byte(x)
			pos += 2
		case x <= 0xffff:
			buf[pos] = 2
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 4
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 8
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
	}

	if value.FreshnessPeriod != nil {
		buf[pos] = byte(25)
		pos += 1
		switch x := uint64(*value.FreshnessPeriod / time.Millisecond); {
		case x <= 0xff:
			buf[pos] = 1
			buf[pos+1] = byte(x)
			pos += 2
		case x <= 0xffff:
			buf[pos] = 2
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 4
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 8
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
	}

	if value.FinalBlockID != nil {
		buf[pos] = byte(26)
		pos += 1
		switch x := len(value.FinalBlockID); {
		case x <= 0xfc:
			buf[pos] = byte(x)
			pos += 1
		case x <= 0xffff:
			buf[pos] = 0xfd
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 0xfe
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 0xff
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
		copy(buf[pos:], value.FinalBlockID)
		pos += uint(len(value.FinalBlockID))
	}

}

func (encoder *MetaInfoEncoder) Encode(value *MetaInfo) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *MetaInfoParsingContext) Parse(reader enc.ParseReader, ignoreCritical bool) (*MetaInfo, error) {
	if reader == nil {
		return nil, enc.ErrBufferOverflow
	}
	progress := -1
	value := &MetaInfo{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		err = nil
		for handled := false; !handled; progress++ {
			switch typ {
			case 24:
				if progress+1 == 0 {
					handled = true
					{
						tempVal := uint64(0)
						tempVal = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								tempVal = uint64(tempVal<<8) | uint64(x)
							}
						}
						value.ContentType = &tempVal
					}

				}
			case 25:
				if progress+1 == 1 {
					handled = true
					{
						timeInt := uint64(0)
						timeInt = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								timeInt = uint64(timeInt<<8) | uint64(x)
							}
						}
						tempVal := time.Duration(timeInt) * time.Millisecond
						value.FreshnessPeriod = &tempVal
					}

				}
			case 26:
				if progress+1 == 2 {
					handled = true
					value.FinalBlockID = make([]byte, l)
					_, err = io.ReadFull(reader, value.FinalBlockID)

				}
			default:
				handled = true
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
				switch progress {
				case 0 - 1:
					value.ContentType = nil
				case 1 - 1:
					value.FreshnessPeriod = nil
				case 2 - 1:
					value.FinalBlockID = nil
				}
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}
	startPos = reader.Pos()
	for ; progress < 3; progress++ {
		switch progress {
		case 0 - 1:
			value.ContentType = nil
		case 1 - 1:
			value.FreshnessPeriod = nil
		case 2 - 1:
			value.FinalBlockID = nil
		}
	}
	if err != nil {
		return nil, err
	}
	return value, nil
}

func (value *MetaInfo) Encode() enc.Wire {
	encoder := MetaInfoEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *MetaInfo) Bytes() []byte {
	return value.Encode().Join()
}

func ParseMetaInfo(reader enc.ParseReader, ignoreCritical bool) (*MetaInfo, error) {
	context := MetaInfoParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type ValidityPeriodEncoder struct {
	length uint
}

type ValidityPeriodParsingContext struct {
}

func (encoder *ValidityPeriodEncoder) Init(value *ValidityPeriod) {

	l := uint(0)
	l += 3
	switch x := len(value.NotBefore); {
	case x <= 0xfc:
		l += 1
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	l += uint(len(value.NotBefore))

	l += 3
	switch x := len(value.NotAfter); {
	case x <= 0xfc:
		l += 1
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	l += uint(len(value.NotAfter))

	encoder.length = l

}

func (context *ValidityPeriodParsingContext) Init() {

}

func (encoder *ValidityPeriodEncoder) EncodeInto(value *ValidityPeriod, buf []byte) {

	pos := uint(0)
	buf[pos] = 253
	binary.BigEndian.PutUint16(buf[pos+1:], uint16(254))
	pos += 3
	switch x := len(value.NotBefore); {
	case x <= 0xfc:
		buf[pos] = byte(x)
		pos += 1
	case x <= 0xffff:
		buf[pos] = 0xfd
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 0xfe
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 0xff
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
	copy(buf[pos:], value.NotBefore)
	pos += uint(len(value.NotBefore))

	buf[pos] = 253
	binary.BigEndian.PutUint16(buf[pos+1:], uint16(255))
	pos += 3
	switch x := len(value.NotAfter); {
	case x <= 0xfc:
		buf[pos] = byte(x)
		pos += 1
	case x <= 0xffff:
		buf[pos] = 0xfd
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 0xfe
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 0xff
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
	copy(buf[pos:], value.NotAfter)
	pos += uint(len(value.NotAfter))

}

func (encoder *ValidityPeriodEncoder) Encode(value *ValidityPeriod) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *ValidityPeriodParsingContext) Parse(reader enc.ParseReader, ignoreCritical bool) (*ValidityPeriod, error) {
	if reader == nil {
		return nil, enc.ErrBufferOverflow
	}
	progress := -1
	value := &ValidityPeriod{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		err = nil
		for handled := false; !handled; progress++ {
			switch typ {
			case 254:
				if progress+1 == 0 {
					handled = true
					{
						var builder strings.Builder
						_, err = io.CopyN(&builder, reader, int64(l))
						if err == nil {
							value.NotBefore = builder.String()
						}
					}

				}
			case 255:
				if progress+1 == 1 {
					handled = true
					{
						var builder strings.Builder
						_, err = io.CopyN(&builder, reader, int64(l))
						if err == nil {
							value.NotAfter = builder.String()
						}
					}

				}
			default:
				handled = true
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
				switch progress {
				case 0 - 1:
					err = enc.ErrSkipRequired{TypeNum: 254}
				case 1 - 1:
					err = enc.ErrSkipRequired{TypeNum: 255}
				}
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}
	startPos = reader.Pos()
	for ; progress < 2; progress++ {
		switch progress {
		case 0 - 1:
			err = enc.ErrSkipRequired{TypeNum: 254}
		case 1 - 1:
			err = enc.ErrSkipRequired{TypeNum: 255}
		}
	}
	if err != nil {
		return nil, err
	}
	return value, nil
}

func (value *ValidityPeriod) Encode() enc.Wire {
	encoder := ValidityPeriodEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *ValidityPeriod) Bytes() []byte {
	return value.Encode().Join()
}

func ParseValidityPeriod(reader enc.ParseReader, ignoreCritical bool) (*ValidityPeriod, error) {
	context := ValidityPeriodParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type CertDescriptionEntryEncoder struct {
	length uint
}

type CertDescriptionEntryParsingContext struct {
}

func (encoder *CertDescriptionEntryEncoder) Init(value *CertDescriptionEntry) {

	l := uint(0)
	l += 3
	switch x := len(value.DescriptionKey); {
	case x <= 0xfc:
		l += 1
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	l += uint(len(value.DescriptionKey))

	l += 3
	switch x := len(value.DescriptionValue); {
	case x <= 0xfc:
		l += 1
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}
	l += uint(len(value.DescriptionValue))

	encoder.length = l

}

func (context *CertDescriptionEntryParsingContext) Init() {

}

func (encoder *CertDescriptionEntryEncoder) EncodeInto(value *CertDescriptionEntry, buf []byte) {

	pos := uint(0)
	buf[pos] = 253
	binary.BigEndian.PutUint16(buf[pos+1:], uint16(513))
	pos += 3
	switch x := len(value.DescriptionKey); {
	case x <= 0xfc:
		buf[pos] = byte(x)
		pos += 1
	case x <= 0xffff:
		buf[pos] = 0xfd
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 0xfe
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 0xff
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
	copy(buf[pos:], value.DescriptionKey)
	pos += uint(len(value.DescriptionKey))

	buf[pos] = 253
	binary.BigEndian.PutUint16(buf[pos+1:], uint16(514))
	pos += 3
	switch x := len(value.DescriptionValue); {
	case x <= 0xfc:
		buf[pos] = byte(x)
		pos += 1
	case x <= 0xffff:
		buf[pos] = 0xfd
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 0xfe
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 0xff
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}
	copy(buf[pos:], value.DescriptionValue)
	pos += uint(len(value.DescriptionValue))

}

func (encoder *CertDescriptionEntryEncoder) Encode(value *CertDescriptionEntry) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *CertDescriptionEntryParsingContext) Parse(reader enc.ParseReader, ignoreCritical bool) (*CertDescriptionEntry, error) {
	if reader == nil {
		return nil, enc.ErrBufferOverflow
	}
	progress := -1
	value := &CertDescriptionEntry{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		err = nil
		for handled := false; !handled; progress++ {
			switch typ {
			case 513:
				if progress+1 == 0 {
					handled = true
					{
						var builder strings.Builder
						_, err = io.CopyN(&builder, reader, int64(l))
						if err == nil {
							value.DescriptionKey = builder.String()
						}
					}

				}
			case 514:
				if progress+1 == 1 {
					handled = true
					{
						var builder strings.Builder
						_, err = io.CopyN(&builder, reader, int64(l))
						if err == nil {
							value.DescriptionValue = builder.String()
						}
					}

				}
			default:
				handled = true
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
				switch progress {
				case 0 - 1:
					err = enc.ErrSkipRequired{TypeNum: 513}
				case 1 - 1:
					err = enc.ErrSkipRequired{TypeNum: 514}
				}
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}
	startPos = reader.Pos()
	for ; progress < 2; progress++ {
		switch progress {
		case 0 - 1:
			err = enc.ErrSkipRequired{TypeNum: 513}
		case 1 - 1:
			err = enc.ErrSkipRequired{TypeNum: 514}
		}
	}
	if err != nil {
		return nil, err
	}
	return value, nil
}

func (value *CertDescriptionEntry) Encode() enc.Wire {
	encoder := CertDescriptionEntryEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *CertDescriptionEntry) Bytes() []byte {
	return value.Encode().Join()
}

func ParseCertDescriptionEntry(reader enc.ParseReader, ignoreCritical bool) (*CertDescriptionEntry, error) {
	context := CertDescriptionEntryParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type CertAdditionalDescriptionEncoder struct {
	length uint

	DescriptionEntries_subencoder []struct {
		DescriptionEntries_encoder CertDescriptionEntryEncoder
	}
}

type CertAdditionalDescriptionParsingContext struct {
	DescriptionEntries_context CertDescriptionEntryParsingContext
}

func (encoder *CertAdditionalDescriptionEncoder) Init(value *CertAdditionalDescription) {
	{
		DescriptionEntries_l := len(value.DescriptionEntries)
		encoder.DescriptionEntries_subencoder = make([]struct {
			DescriptionEntries_encoder CertDescriptionEntryEncoder
		}, DescriptionEntries_l)
		for i := 0; i < DescriptionEntries_l; i++ {
			pseudoEncoder := &encoder.DescriptionEntries_subencoder[i]
			pseudoValue := struct {
				DescriptionEntries *CertDescriptionEntry
			}{
				DescriptionEntries: value.DescriptionEntries[i],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.DescriptionEntries != nil {
					encoder.DescriptionEntries_encoder.Init(value.DescriptionEntries)
				}
				_ = encoder
				_ = value
			}
		}
	}

	l := uint(0)
	if value.DescriptionEntries != nil {
		for seq_i, seq_v := range value.DescriptionEntries {
			pseudoEncoder := &encoder.DescriptionEntries_subencoder[seq_i]
			pseudoValue := struct {
				DescriptionEntries *CertDescriptionEntry
			}{
				DescriptionEntries: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.DescriptionEntries != nil {
					l += 3
					switch x := encoder.DescriptionEntries_encoder.length; {
					case x <= 0xfc:
						l += 1
					case x <= 0xffff:
						l += 3
					case x <= 0xffffffff:
						l += 5
					default:
						l += 9
					}
					l += encoder.DescriptionEntries_encoder.length
				}

				_ = encoder
				_ = value
			}
		}
	}

	encoder.length = l

}

func (context *CertAdditionalDescriptionParsingContext) Init() {
	context.DescriptionEntries_context.Init()
}

func (encoder *CertAdditionalDescriptionEncoder) EncodeInto(value *CertAdditionalDescription, buf []byte) {

	pos := uint(0)
	if value.DescriptionEntries != nil {
		for seq_i, seq_v := range value.DescriptionEntries {
			pseudoEncoder := &encoder.DescriptionEntries_subencoder[seq_i]
			pseudoValue := struct {
				DescriptionEntries *CertDescriptionEntry
			}{
				DescriptionEntries: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.DescriptionEntries != nil {
					buf[pos] = 253
					binary.BigEndian.PutUint16(buf[pos+1:], uint16(512))
					pos += 3
					switch x := encoder.DescriptionEntries_encoder.length; {
					case x <= 0xfc:
						buf[pos] = byte(x)
						pos += 1
					case x <= 0xffff:
						buf[pos] = 0xfd
						binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
						pos += 3
					case x <= 0xffffffff:
						buf[pos] = 0xfe
						binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
						pos += 5
					default:
						buf[pos] = 0xff
						binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
						pos += 9
					}
					if encoder.DescriptionEntries_encoder.length > 0 {
						encoder.DescriptionEntries_encoder.EncodeInto(value.DescriptionEntries, buf[pos:])
						pos += encoder.DescriptionEntries_encoder.length
					}
				}

				_ = encoder
				_ = value
			}
		}
	}

}

func (encoder *CertAdditionalDescriptionEncoder) Encode(value *CertAdditionalDescription) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *CertAdditionalDescriptionParsingContext) Parse(reader enc.ParseReader, ignoreCritical bool) (*CertAdditionalDescription, error) {
	if reader == nil {
		return nil, enc.ErrBufferOverflow
	}
	progress := -1
	value := &CertAdditionalDescription{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		err = nil
		for handled := false; !handled; progress++ {
			switch typ {
			case 512:
				if progress+1 == 0 {
					handled = true
					if value.DescriptionEntries == nil {
						value.DescriptionEntries = make([]*CertDescriptionEntry, 0)
					}
					{
						pseudoValue := struct {
							DescriptionEntries *CertDescriptionEntry
						}{}
						{
							value := &pseudoValue
							value.DescriptionEntries, err = context.DescriptionEntries_context.Parse(reader.Delegate(int(l)), ignoreCritical)
							_ = value
						}
						value.DescriptionEntries = append(value.DescriptionEntries, pseudoValue.DescriptionEntries)
					}
					progress--

				}
			default:
				handled = true
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
				switch progress {
				case 0 - 1:

				}
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}
	startPos = reader.Pos()
	for ; progress < 1; progress++ {
		switch progress {
		case 0 - 1:

		}
	}
	if err != nil {
		return nil, err
	}
	return value, nil
}

func (value *CertAdditionalDescription) Encode() enc.Wire {
	encoder := CertAdditionalDescriptionEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *CertAdditionalDescription) Bytes() []byte {
	return value.Encode().Join()
}

func ParseCertAdditionalDescription(reader enc.ParseReader, ignoreCritical bool) (*CertAdditionalDescription, error) {
	context := CertAdditionalDescriptionParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type SignatureInfoEncoder struct {
	length uint

	KeyLocator_encoder KeyLocatorEncoder

	ValidityPeriod_encoder        ValidityPeriodEncoder
	AdditionalDescription_encoder CertAdditionalDescriptionEncoder
}

type SignatureInfoParsingContext struct {
	KeyLocator_context KeyLocatorParsingContext

	ValidityPeriod_context        ValidityPeriodParsingContext
	AdditionalDescription_context CertAdditionalDescriptionParsingContext
}

func (encoder *SignatureInfoEncoder) Init(value *SignatureInfo) {

	if value.KeyLocator != nil {
		encoder.KeyLocator_encoder.Init(value.KeyLocator)
	}

	if value.ValidityPeriod != nil {
		encoder.ValidityPeriod_encoder.Init(value.ValidityPeriod)
	}
	if value.AdditionalDescription != nil {
		encoder.AdditionalDescription_encoder.Init(value.AdditionalDescription)
	}
	l := uint(0)
	l += 1
	switch x := value.SignatureType; {
	case x <= 0xff:
		l += 2
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}

	if value.KeyLocator != nil {
		l += 1
		switch x := encoder.KeyLocator_encoder.length; {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		l += encoder.KeyLocator_encoder.length
	}

	if value.SignatureNonce != nil {
		l += 1
		switch x := len(value.SignatureNonce); {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		l += uint(len(value.SignatureNonce))
	}

	if value.SignatureTime != nil {
		l += 1
		switch x := uint64(*value.SignatureTime / time.Millisecond); {
		case x <= 0xff:
			l += 2
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
	}

	if value.SignatureSeqNum != nil {
		l += 1
		switch x := *value.SignatureSeqNum; {
		case x <= 0xff:
			l += 2
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
	}

	if value.ValidityPeriod != nil {
		l += 3
		switch x := encoder.ValidityPeriod_encoder.length; {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		l += encoder.ValidityPeriod_encoder.length
	}

	if value.AdditionalDescription != nil {
		l += 3
		switch x := encoder.AdditionalDescription_encoder.length; {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		l += encoder.AdditionalDescription_encoder.length
	}

	encoder.length = l

}

func (context *SignatureInfoParsingContext) Init() {

	context.KeyLocator_context.Init()

	context.ValidityPeriod_context.Init()
	context.AdditionalDescription_context.Init()
}

func (encoder *SignatureInfoEncoder) EncodeInto(value *SignatureInfo, buf []byte) {

	pos := uint(0)
	buf[pos] = byte(27)
	pos += 1
	switch x := value.SignatureType; {
	case x <= 0xff:
		buf[pos] = 1
		buf[pos+1] = byte(x)
		pos += 2
	case x <= 0xffff:
		buf[pos] = 2
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 4
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 8
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}

	if value.KeyLocator != nil {
		buf[pos] = byte(28)
		pos += 1
		switch x := encoder.KeyLocator_encoder.length; {
		case x <= 0xfc:
			buf[pos] = byte(x)
			pos += 1
		case x <= 0xffff:
			buf[pos] = 0xfd
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 0xfe
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 0xff
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
		if encoder.KeyLocator_encoder.length > 0 {
			encoder.KeyLocator_encoder.EncodeInto(value.KeyLocator, buf[pos:])
			pos += encoder.KeyLocator_encoder.length
		}
	}

	if value.SignatureNonce != nil {
		buf[pos] = byte(38)
		pos += 1
		switch x := len(value.SignatureNonce); {
		case x <= 0xfc:
			buf[pos] = byte(x)
			pos += 1
		case x <= 0xffff:
			buf[pos] = 0xfd
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 0xfe
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 0xff
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
		copy(buf[pos:], value.SignatureNonce)
		pos += uint(len(value.SignatureNonce))
	}

	if value.SignatureTime != nil {
		buf[pos] = byte(40)
		pos += 1
		switch x := uint64(*value.SignatureTime / time.Millisecond); {
		case x <= 0xff:
			buf[pos] = 1
			buf[pos+1] = byte(x)
			pos += 2
		case x <= 0xffff:
			buf[pos] = 2
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 4
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 8
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
	}

	if value.SignatureSeqNum != nil {
		buf[pos] = byte(42)
		pos += 1
		switch x := *value.SignatureSeqNum; {
		case x <= 0xff:
			buf[pos] = 1
			buf[pos+1] = byte(x)
			pos += 2
		case x <= 0xffff:
			buf[pos] = 2
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 4
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 8
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
	}

	if value.ValidityPeriod != nil {
		buf[pos] = 253
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(253))
		pos += 3
		switch x := encoder.ValidityPeriod_encoder.length; {
		case x <= 0xfc:
			buf[pos] = byte(x)
			pos += 1
		case x <= 0xffff:
			buf[pos] = 0xfd
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 0xfe
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 0xff
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
		if encoder.ValidityPeriod_encoder.length > 0 {
			encoder.ValidityPeriod_encoder.EncodeInto(value.ValidityPeriod, buf[pos:])
			pos += encoder.ValidityPeriod_encoder.length
		}
	}

	if value.AdditionalDescription != nil {
		buf[pos] = 253
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(258))
		pos += 3
		switch x := encoder.AdditionalDescription_encoder.length; {
		case x <= 0xfc:
			buf[pos] = byte(x)
			pos += 1
		case x <= 0xffff:
			buf[pos] = 0xfd
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 0xfe
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 0xff
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
		if encoder.AdditionalDescription_encoder.length > 0 {
			encoder.AdditionalDescription_encoder.EncodeInto(value.AdditionalDescription, buf[pos:])
			pos += encoder.AdditionalDescription_encoder.length
		}
	}

}

func (encoder *SignatureInfoEncoder) Encode(value *SignatureInfo) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *SignatureInfoParsingContext) Parse(reader enc.ParseReader, ignoreCritical bool) (*SignatureInfo, error) {
	if reader == nil {
		return nil, enc.ErrBufferOverflow
	}
	progress := -1
	value := &SignatureInfo{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		err = nil
		for handled := false; !handled; progress++ {
			switch typ {
			case 27:
				if progress+1 == 0 {
					handled = true
					value.SignatureType = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.SignatureType = uint64(value.SignatureType<<8) | uint64(x)
						}
					}
				}
			case 28:
				if progress+1 == 1 {
					handled = true
					value.KeyLocator, err = context.KeyLocator_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			case 38:
				if progress+1 == 2 {
					handled = true
					value.SignatureNonce = make([]byte, l)
					_, err = io.ReadFull(reader, value.SignatureNonce)

				}
			case 40:
				if progress+1 == 3 {
					handled = true
					{
						timeInt := uint64(0)
						timeInt = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								timeInt = uint64(timeInt<<8) | uint64(x)
							}
						}
						tempVal := time.Duration(timeInt) * time.Millisecond
						value.SignatureTime = &tempVal
					}

				}
			case 42:
				if progress+1 == 4 {
					handled = true
					{
						tempVal := uint64(0)
						tempVal = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								tempVal = uint64(tempVal<<8) | uint64(x)
							}
						}
						value.SignatureSeqNum = &tempVal
					}

				}
			case 253:
				if progress+1 == 5 {
					handled = true
					value.ValidityPeriod, err = context.ValidityPeriod_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			case 258:
				if progress+1 == 6 {
					handled = true
					value.AdditionalDescription, err = context.AdditionalDescription_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			default:
				handled = true
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
				switch progress {
				case 0 - 1:
					err = enc.ErrSkipRequired{TypeNum: 27}
				case 1 - 1:
					value.KeyLocator = nil
				case 2 - 1:
					value.SignatureNonce = nil
				case 3 - 1:
					value.SignatureTime = nil
				case 4 - 1:
					value.SignatureSeqNum = nil
				case 5 - 1:
					value.ValidityPeriod = nil
				case 6 - 1:
					value.AdditionalDescription = nil
				}
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}
	startPos = reader.Pos()
	for ; progress < 7; progress++ {
		switch progress {
		case 0 - 1:
			err = enc.ErrSkipRequired{TypeNum: 27}
		case 1 - 1:
			value.KeyLocator = nil
		case 2 - 1:
			value.SignatureNonce = nil
		case 3 - 1:
			value.SignatureTime = nil
		case 4 - 1:
			value.SignatureSeqNum = nil
		case 5 - 1:
			value.ValidityPeriod = nil
		case 6 - 1:
			value.AdditionalDescription = nil
		}
	}
	if err != nil {
		return nil, err
	}
	return value, nil
}

func (value *SignatureInfo) Encode() enc.Wire {
	encoder := SignatureInfoEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *SignatureInfo) Bytes() []byte {
	return value.Encode().Join()
}

func ParseSignatureInfo(reader enc.ParseReader, ignoreCritical bool) (*SignatureInfo, error) {
	context := SignatureInfoParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type NetworkNackEncoder struct {
	length uint
}

type NetworkNackParsingContext struct {
}

func (encoder *NetworkNackEncoder) Init(value *NetworkNack) {

	l := uint(0)
	l += 3
	switch x := value.Reason; {
	case x <= 0xff:
		l += 2
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}

	encoder.length = l

}

func (context *NetworkNackParsingContext) Init() {

}

func (encoder *NetworkNackEncoder) EncodeInto(value *NetworkNack, buf []byte) {

	pos := uint(0)
	buf[pos] = 253
	binary.BigEndian.PutUint16(buf[pos+1:], uint16(801))
	pos += 3
	switch x := value.Reason; {
	case x <= 0xff:
		buf[pos] = 1
		buf[pos+1] = byte(x)
		pos += 2
	case x <= 0xffff:
		buf[pos] = 2
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 4
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 8
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}

}

func (encoder *NetworkNackEncoder) Encode(value *NetworkNack) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *NetworkNackParsingContext) Parse(reader enc.ParseReader, ignoreCritical bool) (*NetworkNack, error) {
	if reader == nil {
		return nil, enc.ErrBufferOverflow
	}
	progress := -1
	value := &NetworkNack{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		err = nil
		for handled := false; !handled; progress++ {
			switch typ {
			case 801:
				if progress+1 == 0 {
					handled = true
					value.Reason = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.Reason = uint64(value.Reason<<8) | uint64(x)
						}
					}
				}
			default:
				handled = true
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
				switch progress {
				case 0 - 1:
					err = enc.ErrSkipRequired{TypeNum: 801}
				}
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}
	startPos = reader.Pos()
	for ; progress < 1; progress++ {
		switch progress {
		case 0 - 1:
			err = enc.ErrSkipRequired{TypeNum: 801}
		}
	}
	if err != nil {
		return nil, err
	}
	return value, nil
}

func (value *NetworkNack) Encode() enc.Wire {
	encoder := NetworkNackEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *NetworkNack) Bytes() []byte {
	return value.Encode().Join()
}

func ParseNetworkNack(reader enc.ParseReader, ignoreCritical bool) (*NetworkNack, error) {
	context := NetworkNackParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type CachePolicyEncoder struct {
	length uint
}

type CachePolicyParsingContext struct {
}

func (encoder *CachePolicyEncoder) Init(value *CachePolicy) {

	l := uint(0)
	l += 3
	switch x := value.CachePolicyType; {
	case x <= 0xff:
		l += 2
	case x <= 0xffff:
		l += 3
	case x <= 0xffffffff:
		l += 5
	default:
		l += 9
	}

	encoder.length = l

}

func (context *CachePolicyParsingContext) Init() {

}

func (encoder *CachePolicyEncoder) EncodeInto(value *CachePolicy, buf []byte) {

	pos := uint(0)
	buf[pos] = 253
	binary.BigEndian.PutUint16(buf[pos+1:], uint16(821))
	pos += 3
	switch x := value.CachePolicyType; {
	case x <= 0xff:
		buf[pos] = 1
		buf[pos+1] = byte(x)
		pos += 2
	case x <= 0xffff:
		buf[pos] = 2
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
		pos += 3
	case x <= 0xffffffff:
		buf[pos] = 4
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
		pos += 5
	default:
		buf[pos] = 8
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
		pos += 9
	}

}

func (encoder *CachePolicyEncoder) Encode(value *CachePolicy) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *CachePolicyParsingContext) Parse(reader enc.ParseReader, ignoreCritical bool) (*CachePolicy, error) {
	if reader == nil {
		return nil, enc.ErrBufferOverflow
	}
	progress := -1
	value := &CachePolicy{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		err = nil
		for handled := false; !handled; progress++ {
			switch typ {
			case 821:
				if progress+1 == 0 {
					handled = true
					value.CachePolicyType = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.CachePolicyType = uint64(value.CachePolicyType<<8) | uint64(x)
						}
					}
				}
			default:
				handled = true
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
				switch progress {
				case 0 - 1:
					err = enc.ErrSkipRequired{TypeNum: 821}
				}
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}
	startPos = reader.Pos()
	for ; progress < 1; progress++ {
		switch progress {
		case 0 - 1:
			err = enc.ErrSkipRequired{TypeNum: 821}
		}
	}
	if err != nil {
		return nil, err
	}
	return value, nil
}

func (value *CachePolicy) Encode() enc.Wire {
	encoder := CachePolicyEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *CachePolicy) Bytes() []byte {
	return value.Encode().Join()
}

func ParseCachePolicy(reader enc.ParseReader, ignoreCritical bool) (*CachePolicy, error) {
	context := CachePolicyParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type LpPacketEncoder struct {
	length uint

	wirePlan []uint

	Nack_encoder NetworkNackEncoder

	CachePolicy_encoder CachePolicyEncoder

	PrefixAnnouncement_length uint
	Fragment_length           uint
}

type LpPacketParsingContext struct {
	Nack_context NetworkNackParsingContext

	CachePolicy_context CachePolicyParsingContext
}

func (encoder *LpPacketEncoder) Init(value *LpPacket) {

	if value.Nack != nil {
		encoder.Nack_encoder.Init(value.Nack)
	}

	if value.CachePolicy != nil {
		encoder.CachePolicy_encoder.Init(value.CachePolicy)
	}

	if value.PrefixAnnouncement != nil {
		encoder.PrefixAnnouncement_length = 0
		for _, c := range value.PrefixAnnouncement {
			encoder.PrefixAnnouncement_length += uint(len(c))
		}
	}

	if value.Fragment != nil {
		encoder.Fragment_length = 0
		for _, c := range value.Fragment {
			encoder.Fragment_length += uint(len(c))
		}
	}

	l := uint(0)
	if value.Sequence != nil {
		l += 1
		l += 1 + 8
	}

	if value.FragIndex != nil {
		l += 1
		switch x := *value.FragIndex; {
		case x <= 0xff:
			l += 2
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
	}

	if value.FragCount != nil {
		l += 1
		switch x := *value.FragCount; {
		case x <= 0xff:
			l += 2
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
	}

	if value.PitToken != nil {
		l += 1
		switch x := len(value.PitToken); {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		l += uint(len(value.PitToken))
	}

	if value.Nack != nil {
		l += 3
		switch x := encoder.Nack_encoder.length; {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		l += encoder.Nack_encoder.length
	}

	if value.IncomingFaceId != nil {
		l += 3
		switch x := *value.IncomingFaceId; {
		case x <= 0xff:
			l += 2
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
	}

	if value.NextHopFaceId != nil {
		l += 3
		switch x := *value.NextHopFaceId; {
		case x <= 0xff:
			l += 2
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
	}

	if value.CachePolicy != nil {
		l += 3
		switch x := encoder.CachePolicy_encoder.length; {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		l += encoder.CachePolicy_encoder.length
	}

	if value.CongestionMark != nil {
		l += 3
		switch x := *value.CongestionMark; {
		case x <= 0xff:
			l += 2
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
	}

	if value.Ack != nil {
		l += 3
		l += 1 + 8
	}

	if value.TxSequence != nil {
		l += 3
		l += 1 + 8
	}

	if value.NonDiscovery {
		l += 3
		l += 1
	}

	if value.PrefixAnnouncement != nil {
		l += 3
		switch x := encoder.PrefixAnnouncement_length; {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		l += encoder.PrefixAnnouncement_length
	}

	if value.Fragment != nil {
		l += 1
		switch x := encoder.Fragment_length; {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		l += encoder.Fragment_length
	}

	encoder.length = l

	wirePlan := make([]uint, 0)
	l = uint(0)
	if value.Sequence != nil {
		l += 1
		l += 1 + 8
	}

	if value.FragIndex != nil {
		l += 1
		switch x := *value.FragIndex; {
		case x <= 0xff:
			l += 2
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
	}

	if value.FragCount != nil {
		l += 1
		switch x := *value.FragCount; {
		case x <= 0xff:
			l += 2
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
	}

	if value.PitToken != nil {
		l += 1
		switch x := len(value.PitToken); {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		l += uint(len(value.PitToken))
	}

	if value.Nack != nil {
		l += 3
		switch x := encoder.Nack_encoder.length; {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		l += encoder.Nack_encoder.length
	}

	if value.IncomingFaceId != nil {
		l += 3
		switch x := *value.IncomingFaceId; {
		case x <= 0xff:
			l += 2
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
	}

	if value.NextHopFaceId != nil {
		l += 3
		switch x := *value.NextHopFaceId; {
		case x <= 0xff:
			l += 2
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
	}

	if value.CachePolicy != nil {
		l += 3
		switch x := encoder.CachePolicy_encoder.length; {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		l += encoder.CachePolicy_encoder.length
	}

	if value.CongestionMark != nil {
		l += 3
		switch x := *value.CongestionMark; {
		case x <= 0xff:
			l += 2
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
	}

	if value.Ack != nil {
		l += 3
		l += 1 + 8
	}

	if value.TxSequence != nil {
		l += 3
		l += 1 + 8
	}

	if value.NonDiscovery {
		l += 3
		l += 1
	}

	if value.PrefixAnnouncement != nil {
		l += 3
		switch x := encoder.PrefixAnnouncement_length; {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		wirePlan = append(wirePlan, l)
		l = 0
		for range value.PrefixAnnouncement {
			wirePlan = append(wirePlan, l)
			l = 0
		}
	}

	if value.Fragment != nil {
		l += 1
		switch x := encoder.Fragment_length; {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		wirePlan = append(wirePlan, l)
		l = 0
		for range value.Fragment {
			wirePlan = append(wirePlan, l)
			l = 0
		}
	}

	if l > 0 {
		wirePlan = append(wirePlan, l)
	}
	encoder.wirePlan = wirePlan
}

func (context *LpPacketParsingContext) Init() {

	context.Nack_context.Init()

	context.CachePolicy_context.Init()

}

func (encoder *LpPacketEncoder) EncodeInto(value *LpPacket, wire enc.Wire) {

	wireIdx := 0
	buf := wire[wireIdx]

	pos := uint(0)
	if value.Sequence != nil {
		buf[pos] = byte(81)
		pos += 1
		buf[pos] = 8

		binary.BigEndian.PutUint64(buf[pos+1:], uint64(*value.Sequence))

		pos += 9
	}

	if value.FragIndex != nil {
		buf[pos] = byte(82)
		pos += 1
		switch x := *value.FragIndex; {
		case x <= 0xff:
			buf[pos] = 1
			buf[pos+1] = byte(x)
			pos += 2
		case x <= 0xffff:
			buf[pos] = 2
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 4
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 8
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
	}

	if value.FragCount != nil {
		buf[pos] = byte(83)
		pos += 1
		switch x := *value.FragCount; {
		case x <= 0xff:
			buf[pos] = 1
			buf[pos+1] = byte(x)
			pos += 2
		case x <= 0xffff:
			buf[pos] = 2
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 4
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 8
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
	}

	if value.PitToken != nil {
		buf[pos] = byte(98)
		pos += 1
		switch x := len(value.PitToken); {
		case x <= 0xfc:
			buf[pos] = byte(x)
			pos += 1
		case x <= 0xffff:
			buf[pos] = 0xfd
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 0xfe
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 0xff
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
		copy(buf[pos:], value.PitToken)
		pos += uint(len(value.PitToken))
	}

	if value.Nack != nil {
		buf[pos] = 253
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(800))
		pos += 3
		switch x := encoder.Nack_encoder.length; {
		case x <= 0xfc:
			buf[pos] = byte(x)
			pos += 1
		case x <= 0xffff:
			buf[pos] = 0xfd
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 0xfe
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 0xff
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
		if encoder.Nack_encoder.length > 0 {
			encoder.Nack_encoder.EncodeInto(value.Nack, buf[pos:])
			pos += encoder.Nack_encoder.length
		}
	}

	if value.IncomingFaceId != nil {
		buf[pos] = 253
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(812))
		pos += 3
		switch x := *value.IncomingFaceId; {
		case x <= 0xff:
			buf[pos] = 1
			buf[pos+1] = byte(x)
			pos += 2
		case x <= 0xffff:
			buf[pos] = 2
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 4
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 8
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
	}

	if value.NextHopFaceId != nil {
		buf[pos] = 253
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(816))
		pos += 3
		switch x := *value.NextHopFaceId; {
		case x <= 0xff:
			buf[pos] = 1
			buf[pos+1] = byte(x)
			pos += 2
		case x <= 0xffff:
			buf[pos] = 2
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 4
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 8
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
	}

	if value.CachePolicy != nil {
		buf[pos] = 253
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(820))
		pos += 3
		switch x := encoder.CachePolicy_encoder.length; {
		case x <= 0xfc:
			buf[pos] = byte(x)
			pos += 1
		case x <= 0xffff:
			buf[pos] = 0xfd
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 0xfe
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 0xff
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
		if encoder.CachePolicy_encoder.length > 0 {
			encoder.CachePolicy_encoder.EncodeInto(value.CachePolicy, buf[pos:])
			pos += encoder.CachePolicy_encoder.length
		}
	}

	if value.CongestionMark != nil {
		buf[pos] = 253
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(832))
		pos += 3
		switch x := *value.CongestionMark; {
		case x <= 0xff:
			buf[pos] = 1
			buf[pos+1] = byte(x)
			pos += 2
		case x <= 0xffff:
			buf[pos] = 2
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 4
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 8
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
	}

	if value.Ack != nil {
		buf[pos] = 253
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(836))
		pos += 3
		buf[pos] = 8

		binary.BigEndian.PutUint64(buf[pos+1:], uint64(*value.Ack))

		pos += 9
	}

	if value.TxSequence != nil {
		buf[pos] = 253
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(840))
		pos += 3
		buf[pos] = 8

		binary.BigEndian.PutUint64(buf[pos+1:], uint64(*value.TxSequence))

		pos += 9
	}

	if value.NonDiscovery {
		buf[pos] = 253
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(844))
		pos += 3
		buf[pos] = byte(0)
		pos += 1
	}

	if value.PrefixAnnouncement != nil {
		buf[pos] = 253
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(848))
		pos += 3
		switch x := encoder.PrefixAnnouncement_length; {
		case x <= 0xfc:
			buf[pos] = byte(x)
			pos += 1
		case x <= 0xffff:
			buf[pos] = 0xfd
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 0xfe
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 0xff
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
		wireIdx++
		pos = 0
		if wireIdx < len(wire) {
			buf = wire[wireIdx]
		} else {
			buf = nil
		}
		for _, w := range value.PrefixAnnouncement {
			wire[wireIdx] = w
			wireIdx++
			pos = 0
			if wireIdx < len(wire) {
				buf = wire[wireIdx]
			} else {
				buf = nil
			}
		}
	}

	if value.Fragment != nil {
		buf[pos] = byte(80)
		pos += 1
		switch x := encoder.Fragment_length; {
		case x <= 0xfc:
			buf[pos] = byte(x)
			pos += 1
		case x <= 0xffff:
			buf[pos] = 0xfd
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 0xfe
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 0xff
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
		wireIdx++
		pos = 0
		if wireIdx < len(wire) {
			buf = wire[wireIdx]
		} else {
			buf = nil
		}
		for _, w := range value.Fragment {
			wire[wireIdx] = w
			wireIdx++
			pos = 0
			if wireIdx < len(wire) {
				buf = wire[wireIdx]
			} else {
				buf = nil
			}
		}
	}

}

func (encoder *LpPacketEncoder) Encode(value *LpPacket) enc.Wire {

	wire := make(enc.Wire, len(encoder.wirePlan))
	for i, l := range encoder.wirePlan {
		if l > 0 {
			wire[i] = make([]byte, l)
		}
	}
	encoder.EncodeInto(value, wire)

	return wire
}

func (context *LpPacketParsingContext) Parse(reader enc.ParseReader, ignoreCritical bool) (*LpPacket, error) {
	if reader == nil {
		return nil, enc.ErrBufferOverflow
	}
	progress := -1
	value := &LpPacket{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		err = nil
		for handled := false; !handled; progress++ {
			switch typ {
			case 81:
				if progress+1 == 0 {
					handled = true
					{
						tempVal := uint64(0)
						tempVal = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								tempVal = uint64(tempVal<<8) | uint64(x)
							}
						}
						value.Sequence = &tempVal
					}

				}
			case 82:
				if progress+1 == 1 {
					handled = true
					{
						tempVal := uint64(0)
						tempVal = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								tempVal = uint64(tempVal<<8) | uint64(x)
							}
						}
						value.FragIndex = &tempVal
					}

				}
			case 83:
				if progress+1 == 2 {
					handled = true
					{
						tempVal := uint64(0)
						tempVal = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								tempVal = uint64(tempVal<<8) | uint64(x)
							}
						}
						value.FragCount = &tempVal
					}

				}
			case 98:
				if progress+1 == 3 {
					handled = true
					value.PitToken = make([]byte, l)
					_, err = io.ReadFull(reader, value.PitToken)

				}
			case 800:
				if progress+1 == 4 {
					handled = true
					value.Nack, err = context.Nack_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			case 812:
				if progress+1 == 5 {
					handled = true
					{
						tempVal := uint64(0)
						tempVal = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								tempVal = uint64(tempVal<<8) | uint64(x)
							}
						}
						value.IncomingFaceId = &tempVal
					}

				}
			case 816:
				if progress+1 == 6 {
					handled = true
					{
						tempVal := uint64(0)
						tempVal = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								tempVal = uint64(tempVal<<8) | uint64(x)
							}
						}
						value.NextHopFaceId = &tempVal
					}

				}
			case 820:
				if progress+1 == 7 {
					handled = true
					value.CachePolicy, err = context.CachePolicy_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			case 832:
				if progress+1 == 8 {
					handled = true
					{
						tempVal := uint64(0)
						tempVal = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								tempVal = uint64(tempVal<<8) | uint64(x)
							}
						}
						value.CongestionMark = &tempVal
					}

				}
			case 836:
				if progress+1 == 9 {
					handled = true
					{
						tempVal := uint64(0)
						tempVal = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								tempVal = uint64(tempVal<<8) | uint64(x)
							}
						}
						value.Ack = &tempVal
					}

				}
			case 840:
				if progress+1 == 10 {
					handled = true
					{
						tempVal := uint64(0)
						tempVal = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								tempVal = uint64(tempVal<<8) | uint64(x)
							}
						}
						value.TxSequence = &tempVal
					}

				}
			case 844:
				if progress+1 == 11 {
					handled = true
					value.NonDiscovery = true
				}
			case 848:
				if progress+1 == 12 {
					handled = true
					value.PrefixAnnouncement, err = reader.ReadWire(int(l))

				}
			case 80:
				if progress+1 == 13 {
					handled = true
					value.Fragment, err = reader.ReadWire(int(l))

				}
			default:
				handled = true
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
				switch progress {
				case 0 - 1:
					value.Sequence = nil
				case 1 - 1:
					value.FragIndex = nil
				case 2 - 1:
					value.FragCount = nil
				case 3 - 1:
					value.PitToken = nil
				case 4 - 1:
					value.Nack = nil
				case 5 - 1:
					value.IncomingFaceId = nil
				case 6 - 1:
					value.NextHopFaceId = nil
				case 7 - 1:
					value.CachePolicy = nil
				case 8 - 1:
					value.CongestionMark = nil
				case 9 - 1:
					value.Ack = nil
				case 10 - 1:
					value.TxSequence = nil
				case 11 - 1:
					value.NonDiscovery = false
				case 12 - 1:
					value.PrefixAnnouncement = nil
				case 13 - 1:
					value.Fragment = nil
				}
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}
	startPos = reader.Pos()
	for ; progress < 14; progress++ {
		switch progress {
		case 0 - 1:
			value.Sequence = nil
		case 1 - 1:
			value.FragIndex = nil
		case 2 - 1:
			value.FragCount = nil
		case 3 - 1:
			value.PitToken = nil
		case 4 - 1:
			value.Nack = nil
		case 5 - 1:
			value.IncomingFaceId = nil
		case 6 - 1:
			value.NextHopFaceId = nil
		case 7 - 1:
			value.CachePolicy = nil
		case 8 - 1:
			value.CongestionMark = nil
		case 9 - 1:
			value.Ack = nil
		case 10 - 1:
			value.TxSequence = nil
		case 11 - 1:
			value.NonDiscovery = false
		case 12 - 1:
			value.PrefixAnnouncement = nil
		case 13 - 1:
			value.Fragment = nil
		}
	}
	if err != nil {
		return nil, err
	}
	return value, nil
}

type DataEncoder struct {
	length uint

	wirePlan []uint

	sigCovered            enc.Wire
	sigCoverStart         int
	sigCoverStart_wireIdx int
	sigCoverStart_pos     int

	NameV_length           uint
	MetaInfo_encoder       MetaInfoEncoder
	ContentV_length        uint
	SignatureInfo_encoder  SignatureInfoEncoder
	SignatureValue_wireIdx int
	SignatureValue_estLen  uint
}

type DataParsingContext struct {
	sigCovered    enc.Wire
	sigCoverStart int

	MetaInfo_context MetaInfoParsingContext

	SignatureInfo_context SignatureInfoParsingContext
}

func (encoder *DataEncoder) Init(value *Data) {

	if value.NameV != nil {
		encoder.NameV_length = 0
		for _, c := range value.NameV {
			encoder.NameV_length += uint(c.EncodingLength())
		}
	}

	if value.MetaInfo != nil {
		encoder.MetaInfo_encoder.Init(value.MetaInfo)
	}
	if value.ContentV != nil {
		encoder.ContentV_length = 0
		for _, c := range value.ContentV {
			encoder.ContentV_length += uint(len(c))
		}
	}

	if value.SignatureInfo != nil {
		encoder.SignatureInfo_encoder.Init(value.SignatureInfo)
	}
	encoder.SignatureValue_wireIdx = -1

	l := uint(0)

	encoder.sigCoverStart = int(l)
	if value.NameV != nil {
		l += 1
		switch x := encoder.NameV_length; {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		l += encoder.NameV_length
	}

	if value.MetaInfo != nil {
		l += 1
		switch x := encoder.MetaInfo_encoder.length; {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		l += encoder.MetaInfo_encoder.length
	}

	if value.ContentV != nil {
		l += 1
		switch x := encoder.ContentV_length; {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		l += encoder.ContentV_length
	}

	if value.SignatureInfo != nil {
		l += 1
		switch x := encoder.SignatureInfo_encoder.length; {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		l += encoder.SignatureInfo_encoder.length
	}

	if encoder.SignatureValue_estLen > 0 {
		l += 1
		switch x := encoder.SignatureValue_estLen; {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		l += encoder.SignatureValue_estLen
	}

	encoder.length = l

	wirePlan := make([]uint, 0)
	l = uint(0)

	if value.NameV != nil {
		l += 1
		switch x := encoder.NameV_length; {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		l += encoder.NameV_length
	}

	if value.MetaInfo != nil {
		l += 1
		switch x := encoder.MetaInfo_encoder.length; {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		l += encoder.MetaInfo_encoder.length
	}

	if value.ContentV != nil {
		l += 1
		switch x := encoder.ContentV_length; {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		wirePlan = append(wirePlan, l)
		l = 0
		for range value.ContentV {
			wirePlan = append(wirePlan, l)
			l = 0
		}
	}

	if value.SignatureInfo != nil {
		l += 1
		switch x := encoder.SignatureInfo_encoder.length; {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		l += encoder.SignatureInfo_encoder.length
	}

	if encoder.SignatureValue_estLen > 0 {
		l += 1
		switch x := encoder.SignatureValue_estLen; {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		wirePlan = append(wirePlan, l)
		l = 0
		encoder.SignatureValue_wireIdx = len(wirePlan)
		wirePlan = append(wirePlan, l)
		l = 0
	}

	if l > 0 {
		wirePlan = append(wirePlan, l)
	}
	encoder.wirePlan = wirePlan
}

func (context *DataParsingContext) Init() {

	context.MetaInfo_context.Init()

	context.SignatureInfo_context.Init()
	context.sigCovered = make(enc.Wire, 0)
}

func (encoder *DataEncoder) EncodeInto(value *Data, wire enc.Wire) {

	wireIdx := 0
	buf := wire[wireIdx]

	pos := uint(0)

	encoder.sigCoverStart_wireIdx = int(wireIdx)
	encoder.sigCoverStart_pos = int(pos)

	if value.NameV != nil {
		buf[pos] = byte(7)
		pos += 1
		switch x := encoder.NameV_length; {
		case x <= 0xfc:
			buf[pos] = byte(x)
			pos += 1
		case x <= 0xffff:
			buf[pos] = 0xfd
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 0xfe
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 0xff
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
		for _, c := range value.NameV {
			pos += uint(c.EncodeInto(buf[pos:]))
		}
	}

	if value.MetaInfo != nil {
		buf[pos] = byte(20)
		pos += 1
		switch x := encoder.MetaInfo_encoder.length; {
		case x <= 0xfc:
			buf[pos] = byte(x)
			pos += 1
		case x <= 0xffff:
			buf[pos] = 0xfd
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 0xfe
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 0xff
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
		if encoder.MetaInfo_encoder.length > 0 {
			encoder.MetaInfo_encoder.EncodeInto(value.MetaInfo, buf[pos:])
			pos += encoder.MetaInfo_encoder.length
		}
	}

	if value.ContentV != nil {
		buf[pos] = byte(21)
		pos += 1
		switch x := encoder.ContentV_length; {
		case x <= 0xfc:
			buf[pos] = byte(x)
			pos += 1
		case x <= 0xffff:
			buf[pos] = 0xfd
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 0xfe
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 0xff
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
		wireIdx++
		pos = 0
		if wireIdx < len(wire) {
			buf = wire[wireIdx]
		} else {
			buf = nil
		}
		for _, w := range value.ContentV {
			wire[wireIdx] = w
			wireIdx++
			pos = 0
			if wireIdx < len(wire) {
				buf = wire[wireIdx]
			} else {
				buf = nil
			}
		}
	}

	if value.SignatureInfo != nil {
		buf[pos] = byte(22)
		pos += 1
		switch x := encoder.SignatureInfo_encoder.length; {
		case x <= 0xfc:
			buf[pos] = byte(x)
			pos += 1
		case x <= 0xffff:
			buf[pos] = 0xfd
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 0xfe
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 0xff
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
		if encoder.SignatureInfo_encoder.length > 0 {
			encoder.SignatureInfo_encoder.EncodeInto(value.SignatureInfo, buf[pos:])
			pos += encoder.SignatureInfo_encoder.length
		}
	}

	if encoder.SignatureValue_estLen > 0 {
		startPos := int(pos)
		buf[pos] = byte(23)
		pos += 1
		switch x := encoder.SignatureValue_estLen; {
		case x <= 0xfc:
			buf[pos] = byte(x)
			pos += 1
		case x <= 0xffff:
			buf[pos] = 0xfd
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 0xfe
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 0xff
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
		if encoder.sigCoverStart_wireIdx == int(wireIdx) {
			coveredPart := buf[encoder.sigCoverStart:startPos]
			encoder.sigCovered = append(encoder.sigCovered, coveredPart)
		} else {
			coverStart := wire[encoder.sigCoverStart_wireIdx][encoder.sigCoverStart:]
			encoder.sigCovered = append(encoder.sigCovered, coverStart)
			for i := encoder.sigCoverStart_wireIdx + 1; i < int(wireIdx); i++ {
				encoder.sigCovered = append(encoder.sigCovered, wire[i])
			}
			coverEnd := buf[:startPos]
			encoder.sigCovered = append(encoder.sigCovered, coverEnd)
		}
		wireIdx++
		pos = 0
		if wireIdx < len(wire) {
			buf = wire[wireIdx]
		} else {
			buf = nil
		}
		wireIdx++
		pos = 0
		if wireIdx < len(wire) {
			buf = wire[wireIdx]
		} else {
			buf = nil
		}
	}

}

func (encoder *DataEncoder) Encode(value *Data) enc.Wire {

	wire := make(enc.Wire, len(encoder.wirePlan))
	for i, l := range encoder.wirePlan {
		if l > 0 {
			wire[i] = make([]byte, l)
		}
	}
	encoder.EncodeInto(value, wire)

	return wire
}

func (context *DataParsingContext) Parse(reader enc.ParseReader, ignoreCritical bool) (*Data, error) {
	if reader == nil {
		return nil, enc.ErrBufferOverflow
	}
	progress := -1
	value := &Data{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		err = nil
		for handled := false; !handled; progress++ {
			switch typ {
			case 7:
				if progress+1 == 2 {
					handled = true
					value.NameV = make(enc.Name, 0)
					startName := reader.Pos()
					endName := startName + int(l)
					for reader.Pos() < endName {
						c, err := enc.ReadComponent(reader)
						if err != nil {
							break
						}
						value.NameV = append(value.NameV, *c)
					}
					if err != nil && reader.Pos() != endName {
						err = enc.ErrBufferOverflow
					}

				}
			case 20:
				if progress+1 == 3 {
					handled = true
					value.MetaInfo, err = context.MetaInfo_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			case 21:
				if progress+1 == 4 {
					handled = true
					value.ContentV, err = reader.ReadWire(int(l))

				}
			case 22:
				if progress+1 == 5 {
					handled = true
					value.SignatureInfo, err = context.SignatureInfo_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			case 23:
				if progress+1 == 6 {
					handled = true
					value.SignatureValue, err = reader.ReadWire(int(l))
					if err == nil {
						coveredPart := reader.Range(context.sigCoverStart, startPos)
						context.sigCovered = append(context.sigCovered, coveredPart...)
					}

				}
			default:
				handled = true
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
				switch progress {
				case 0 - 1:

				case 1 - 1:
					context.sigCoverStart = int(startPos)
				case 2 - 1:
					value.NameV = nil
				case 3 - 1:
					value.MetaInfo = nil
				case 4 - 1:
					value.ContentV = nil
				case 5 - 1:
					value.SignatureInfo = nil
				case 6 - 1:
					value.SignatureValue = nil
				}
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}
	startPos = reader.Pos()
	for ; progress < 7; progress++ {
		switch progress {
		case 0 - 1:

		case 1 - 1:
			context.sigCoverStart = int(startPos)
		case 2 - 1:
			value.NameV = nil
		case 3 - 1:
			value.MetaInfo = nil
		case 4 - 1:
			value.ContentV = nil
		case 5 - 1:
			value.SignatureInfo = nil
		case 6 - 1:
			value.SignatureValue = nil
		}
	}
	if err != nil {
		return nil, err
	}
	return value, nil
}

type PacketEncoder struct {
	length uint

	wirePlan []uint

	Data_encoder     DataEncoder
	LpPacket_encoder LpPacketEncoder
}

type PacketParsingContext struct {
	Data_context     DataParsingContext
	LpPacket_context LpPacketParsingContext
}

func (encoder *PacketEncoder) Init(value *Packet) {
	if value.Data != nil {
		encoder.Data_encoder.Init(value.Data)
	}
	if value.LpPacket != nil {
		encoder.LpPacket_encoder.Init(value.LpPacket)
	}
	l := uint(0)
	if value.Data != nil {
		l += 1
		switch x := encoder.Data_encoder.length; {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		l += encoder.Data_encoder.length
	}

	if value.LpPacket != nil {
		l += 1
		switch x := encoder.LpPacket_encoder.length; {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		l += encoder.LpPacket_encoder.length
	}

	encoder.length = l

	wirePlan := make([]uint, 0)
	l = uint(0)
	if value.Data != nil {
		l += 1
		switch x := encoder.Data_encoder.length; {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		if encoder.Data_encoder.length > 0 {
			l += encoder.Data_encoder.wirePlan[0]
			for i := 1; i < len(encoder.Data_encoder.wirePlan); i++ {
				wirePlan = append(wirePlan, l)
				l = 0
				l = encoder.Data_encoder.wirePlan[i]
			}
			if l == 0 {
				wirePlan = append(wirePlan, l)
				l = 0
			}
		}
	}

	if value.LpPacket != nil {
		l += 1
		switch x := encoder.LpPacket_encoder.length; {
		case x <= 0xfc:
			l += 1
		case x <= 0xffff:
			l += 3
		case x <= 0xffffffff:
			l += 5
		default:
			l += 9
		}
		if encoder.LpPacket_encoder.length > 0 {
			l += encoder.LpPacket_encoder.wirePlan[0]
			for i := 1; i < len(encoder.LpPacket_encoder.wirePlan); i++ {
				wirePlan = append(wirePlan, l)
				l = 0
				l = encoder.LpPacket_encoder.wirePlan[i]
			}
			if l == 0 {
				wirePlan = append(wirePlan, l)
				l = 0
			}
		}
	}

	if l > 0 {
		wirePlan = append(wirePlan, l)
	}
	encoder.wirePlan = wirePlan
}

func (context *PacketParsingContext) Init() {
	context.Data_context.Init()
	context.LpPacket_context.Init()
}

func (encoder *PacketEncoder) EncodeInto(value *Packet, wire enc.Wire) {

	wireIdx := 0
	buf := wire[wireIdx]

	pos := uint(0)
	if value.Data != nil {
		buf[pos] = byte(6)
		pos += 1
		switch x := encoder.Data_encoder.length; {
		case x <= 0xfc:
			buf[pos] = byte(x)
			pos += 1
		case x <= 0xffff:
			buf[pos] = 0xfd
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 0xfe
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 0xff
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
		if encoder.Data_encoder.length > 0 {
			{
				subWire := make(enc.Wire, len(encoder.Data_encoder.wirePlan))
				subWire[0] = buf[pos:]
				for i := 1; i < len(subWire); i++ {
					subWire[i] = wire[wireIdx+i]
				}
				encoder.Data_encoder.EncodeInto(value.Data, subWire)
				for i := 1; i < len(subWire); i++ {
					wire[wireIdx+i] = subWire[i]
				}
				if lastL := encoder.Data_encoder.wirePlan[len(subWire)-1]; lastL > 0 {
					wireIdx += len(subWire) - 1
					if len(subWire) > 1 {
						pos = lastL
					} else {
						pos += lastL
					}
				} else {
					wireIdx += len(subWire)
					pos = 0
				}
				if wireIdx < len(wire) {
					buf = wire[wireIdx]
				} else {
					buf = nil
				}
			}
		}
	}

	if value.LpPacket != nil {
		buf[pos] = byte(100)
		pos += 1
		switch x := encoder.LpPacket_encoder.length; {
		case x <= 0xfc:
			buf[pos] = byte(x)
			pos += 1
		case x <= 0xffff:
			buf[pos] = 0xfd
			binary.BigEndian.PutUint16(buf[pos+1:], uint16(x))
			pos += 3
		case x <= 0xffffffff:
			buf[pos] = 0xfe
			binary.BigEndian.PutUint32(buf[pos+1:], uint32(x))
			pos += 5
		default:
			buf[pos] = 0xff
			binary.BigEndian.PutUint64(buf[pos+1:], uint64(x))
			pos += 9
		}
		if encoder.LpPacket_encoder.length > 0 {
			{
				subWire := make(enc.Wire, len(encoder.LpPacket_encoder.wirePlan))
				subWire[0] = buf[pos:]
				for i := 1; i < len(subWire); i++ {
					subWire[i] = wire[wireIdx+i]
				}
				encoder.LpPacket_encoder.EncodeInto(value.LpPacket, subWire)
				for i := 1; i < len(subWire); i++ {
					wire[wireIdx+i] = subWire[i]
				}
				if lastL := encoder.LpPacket_encoder.wirePlan[len(subWire)-1]; lastL > 0 {
					wireIdx += len(subWire) - 1
					if len(subWire) > 1 {
						pos = lastL
					} else {
						pos += lastL
					}
				} else {
					wireIdx += len(subWire)
					pos = 0
				}
				if wireIdx < len(wire) {
					buf = wire[wireIdx]
				} else {
					buf = nil
				}
			}
		}
	}

}

func (encoder *PacketEncoder) Encode(value *Packet) enc.Wire {

	wire := make(enc.Wire, len(encoder.wirePlan))
	for i, l := range encoder.wirePlan {
		if l > 0 {
			wire[i] = make([]byte, l)
		}
	}
	encoder.EncodeInto(value, wire)

	return wire
}

func (context *PacketParsingContext) Parse(reader enc.ParseReader, ignoreCritical bool) (*Packet, error) {
	if reader == nil {
		return nil, enc.ErrBufferOverflow
	}
	progress := -1
	value := &Packet{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = enc.ReadTLNum(reader)
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		err = nil
		for handled := false; !handled; progress++ {
			switch typ {
			case 6:
				if progress+1 == 0 {
					handled = true
					value.Data, err = context.Data_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			case 100:
				if progress+1 == 1 {
					handled = true
					value.LpPacket, err = context.LpPacket_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			default:
				handled = true
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
				switch progress {
				case 0 - 1:
					value.Data = nil
				case 1 - 1:
					value.LpPacket = nil
				}
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}
	startPos = reader.Pos()
	for ; progress < 2; progress++ {
		switch progress {
		case 0 - 1:
			value.Data = nil
		case 1 - 1:
			value.LpPacket = nil
		}
	}
	if err != nil {
		return nil, err
	}
	return value, nil
}
